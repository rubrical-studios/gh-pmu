
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>cmd: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/scooter-indie/gh-pmu/cmd/create.go (24.1%)</option>
				
				<option value="file1">github.com/scooter-indie/gh-pmu/cmd/init.go (18.6%)</option>
				
				<option value="file2">github.com/scooter-indie/gh-pmu/cmd/intake.go (5.9%)</option>
				
				<option value="file3">github.com/scooter-indie/gh-pmu/cmd/list.go (7.5%)</option>
				
				<option value="file4">github.com/scooter-indie/gh-pmu/cmd/move.go (8.7%)</option>
				
				<option value="file5">github.com/scooter-indie/gh-pmu/cmd/root.go (91.7%)</option>
				
				<option value="file6">github.com/scooter-indie/gh-pmu/cmd/split.go (16.5%)</option>
				
				<option value="file7">github.com/scooter-indie/gh-pmu/cmd/sub.go (10.4%)</option>
				
				<option value="file8">github.com/scooter-indie/gh-pmu/cmd/triage.go (3.4%)</option>
				
				<option value="file9">github.com/scooter-indie/gh-pmu/cmd/view.go (20.1%)</option>
				
				<option value="file10">github.com/scooter-indie/gh-pmu/internal/api/client.go (95.5%)</option>
				
				<option value="file11">github.com/scooter-indie/gh-pmu/internal/api/errors.go (88.9%)</option>
				
				<option value="file12">github.com/scooter-indie/gh-pmu/internal/api/mutations.go (0.0%)</option>
				
				<option value="file13">github.com/scooter-indie/gh-pmu/internal/api/queries.go (0.0%)</option>
				
				<option value="file14">github.com/scooter-indie/gh-pmu/internal/config/config.go (97.0%)</option>
				
				<option value="file15">github.com/scooter-indie/gh-pmu/internal/ui/ui.go (71.4%)</option>
				
				<option value="file16">github.com/scooter-indie/gh-pmu/main.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package cmd

import (
        "fmt"
        "os"
        "strings"

        "github.com/scooter-indie/gh-pmu/internal/api"
        "github.com/scooter-indie/gh-pmu/internal/config"
        "github.com/spf13/cobra"
)

type createOptions struct {
        title    string
        body     string
        status   string
        priority string
        labels   []string
}

func newCreateCommand() *cobra.Command <span class="cov10" title="51">{
        opts := &amp;createOptions{}

        cmd := &amp;cobra.Command{
                Use:   "create",
                Short: "Create an issue with project metadata",
                Long: `Create a new issue and add it to the configured project.

When --title is provided, creates the issue non-interactively.
Otherwise, opens an editor for composing the issue.

The issue is automatically added to the configured project and
any specified field values (status, priority) are set.`,
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov1" title="1">{
                        return runCreate(cmd, opts)
                }</span>,
        }

        <span class="cov10" title="51">cmd.Flags().StringVarP(&amp;opts.title, "title", "t", "", "Issue title (required for non-interactive mode)")
        cmd.Flags().StringVarP(&amp;opts.body, "body", "b", "", "Issue body")
        cmd.Flags().StringVarP(&amp;opts.status, "status", "s", "", "Set project status field (e.g., backlog, in_progress)")
        cmd.Flags().StringVarP(&amp;opts.priority, "priority", "p", "", "Set project priority field (e.g., p0, p1, p2)")
        cmd.Flags().StringArrayVarP(&amp;opts.labels, "label", "l", nil, "Add labels (can be specified multiple times)")

        return cmd</span>
}

func runCreate(cmd *cobra.Command, opts *createOptions) error <span class="cov1" title="1">{
        // Load configuration
        cwd, err := os.Getwd()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get current directory: %w", err)
        }</span>

        <span class="cov1" title="1">cfg, err := config.LoadFromDirectory(cwd)
        if err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("failed to load configuration: %w\nRun 'gh pmu init' to create a configuration file", err)
        }</span>

        <span class="cov0" title="0">if err := cfg.Validate(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid configuration: %w", err)
        }</span>

        // Get repository
        <span class="cov0" title="0">if len(cfg.Repositories) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("no repository configured")
        }</span>

        <span class="cov0" title="0">repoParts := strings.Split(cfg.Repositories[0], "/")
        if len(repoParts) != 2 </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid repository format in config: %s", cfg.Repositories[0])
        }</span>
        <span class="cov0" title="0">owner, repo := repoParts[0], repoParts[1]

        // Handle interactive vs non-interactive mode
        title := opts.title
        body := opts.body

        if title == "" </span><span class="cov0" title="0">{
                // Interactive mode - open editor
                // For now, require --title flag
                return fmt.Errorf("--title is required (interactive mode not yet implemented)")
        }</span>

        // Merge labels: config defaults + command line
        <span class="cov0" title="0">labels := append([]string{}, cfg.Defaults.Labels...)
        labels = append(labels, opts.labels...)

        // Create API client
        client := api.NewClient()

        // Create the issue
        issue, err := client.CreateIssue(owner, repo, title, body, labels)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create issue: %w", err)
        }</span>

        // Add issue to project
        <span class="cov0" title="0">project, err := client.GetProject(cfg.Project.Owner, cfg.Project.Number)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get project: %w", err)
        }</span>

        <span class="cov0" title="0">itemID, err := client.AddIssueToProject(project.ID, issue.ID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to add issue to project: %w", err)
        }</span>

        // Set project field values
        <span class="cov0" title="0">if opts.status != "" </span><span class="cov0" title="0">{
                statusValue := cfg.ResolveFieldValue("status", opts.status)
                if err := client.SetProjectItemField(project.ID, itemID, "Status", statusValue); err != nil </span><span class="cov0" title="0">{
                        // Non-fatal - warn but continue
                        fmt.Fprintf(os.Stderr, "Warning: failed to set status: %v\n", err)
                }</span>
        } else<span class="cov0" title="0"> if cfg.Defaults.Status != "" </span><span class="cov0" title="0">{
                // Apply default status from config
                statusValue := cfg.ResolveFieldValue("status", cfg.Defaults.Status)
                if err := client.SetProjectItemField(project.ID, itemID, "Status", statusValue); err != nil </span><span class="cov0" title="0">{
                        fmt.Fprintf(os.Stderr, "Warning: failed to set default status: %v\n", err)
                }</span>
        }

        <span class="cov0" title="0">if opts.priority != "" </span><span class="cov0" title="0">{
                priorityValue := cfg.ResolveFieldValue("priority", opts.priority)
                if err := client.SetProjectItemField(project.ID, itemID, "Priority", priorityValue); err != nil </span><span class="cov0" title="0">{
                        fmt.Fprintf(os.Stderr, "Warning: failed to set priority: %v\n", err)
                }</span>
        } else<span class="cov0" title="0"> if cfg.Defaults.Priority != "" </span><span class="cov0" title="0">{
                // Apply default priority from config
                priorityValue := cfg.ResolveFieldValue("priority", cfg.Defaults.Priority)
                if err := client.SetProjectItemField(project.ID, itemID, "Priority", priorityValue); err != nil </span><span class="cov0" title="0">{
                        fmt.Fprintf(os.Stderr, "Warning: failed to set default priority: %v\n", err)
                }</span>
        }

        // Output the result
        <span class="cov0" title="0">fmt.Printf("Created issue #%d: %s\n", issue.Number, issue.Title)
        fmt.Printf("%s\n", issue.URL)

        return nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package cmd

import (
        "bufio"
        "fmt"
        "os"
        "os/exec"
        "path/filepath"
        "regexp"
        "strconv"
        "strings"

        "github.com/scooter-indie/gh-pmu/internal/api"
        "github.com/scooter-indie/gh-pmu/internal/ui"
        "github.com/spf13/cobra"
        "gopkg.in/yaml.v3"
)

func newInitCommand() *cobra.Command <span class="cov10" title="51">{
        cmd := &amp;cobra.Command{
                Use:   "init",
                Short: "Initialize gh-pmu configuration for the current project",
                Long: `Initialize gh-pmu configuration by creating a .gh-pmu.yml file.

This command will:
- Auto-detect the current repository from git remote
- Discover and list available projects for selection
- Fetch and cache project field metadata from GitHub
- Create a .gh-pmu.yml configuration file`,
                RunE: runInit,
        }

        return cmd
}</span>

func runInit(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
        u := ui.New(cmd.OutOrStdout())
        reader := bufio.NewReader(os.Stdin)

        // Print header
        u.Header("gh-pmu init", "Configure project management settings")
        fmt.Fprintln(cmd.OutOrStdout())

        // Check if config already exists
        if _, err := os.Stat(".gh-pmu.yml"); err == nil </span><span class="cov0" title="0">{
                u.Warning("Configuration file .gh-pmu.yml already exists")
                fmt.Fprint(cmd.OutOrStdout(), u.Prompt("Overwrite?", "y/N"))
                response, _ := reader.ReadString('\n')
                response = strings.TrimSpace(strings.ToLower(response))
                if response != "y" &amp;&amp; response != "yes" </span><span class="cov0" title="0">{
                        u.Info("Aborted")
                        return nil
                }</span>
                <span class="cov0" title="0">fmt.Fprintln(cmd.OutOrStdout())</span>
        }

        // Auto-detect repository
        <span class="cov0" title="0">detectedRepo := detectRepository()
        var owner string
        var defaultRepo string

        if detectedRepo != "" </span><span class="cov0" title="0">{
                o, _ := splitRepository(detectedRepo)
                owner = o
                defaultRepo = detectedRepo
                u.Success(fmt.Sprintf("Detected repository: %s", detectedRepo))
        }</span> else<span class="cov0" title="0"> {
                u.Warning("Could not detect repository from git remote")
                fmt.Fprint(cmd.OutOrStdout(), u.Prompt("Repository owner", ""))
                ownerInput, _ := reader.ReadString('\n')
                owner = strings.TrimSpace(ownerInput)
                if owner == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("repository owner is required")
                }</span>
        }

        // Initialize API client
        <span class="cov0" title="0">client := api.NewClient()

        // Fetch projects for owner
        fmt.Fprintln(cmd.OutOrStdout())
        spinner := ui.NewSpinner(cmd.OutOrStdout(), fmt.Sprintf("Fetching projects for %s...", owner))
        spinner.Start()

        projects, err := client.ListProjects(owner)
        spinner.Stop()

        var selectedProject *api.Project
        var projectNumber int

        if err != nil || len(projects) == 0 </span><span class="cov0" title="0">{
                // No projects found or error - fall back to manual entry
                if err != nil </span><span class="cov0" title="0">{
                        u.Warning(fmt.Sprintf("Could not fetch projects: %v", err))
                }</span> else<span class="cov0" title="0"> {
                        u.Warning(fmt.Sprintf("No projects found for %s", owner))
                }</span>
                <span class="cov0" title="0">fmt.Fprintln(cmd.OutOrStdout())

                // Manual project number entry
                fmt.Fprint(cmd.OutOrStdout(), u.Prompt("Project number", ""))
                numberInput, _ := reader.ReadString('\n')
                numberInput = strings.TrimSpace(numberInput)
                projectNumber, err = strconv.Atoi(numberInput)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid project number: %s", numberInput)
                }</span>

                // Validate project exists
                <span class="cov0" title="0">spinner = ui.NewSpinner(cmd.OutOrStdout(), fmt.Sprintf("Validating project %s/%d...", owner, projectNumber))
                spinner.Start()
                selectedProject, err = client.GetProject(owner, projectNumber)
                spinner.Stop()

                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to find project: %w", err)
                }</span>
                <span class="cov0" title="0">u.Success(fmt.Sprintf("Found project: %s", selectedProject.Title))</span>
        } else<span class="cov0" title="0"> {
                // Projects found - show selection menu
                u.Success(fmt.Sprintf("Found %d project(s)", len(projects)))
                fmt.Fprintln(cmd.OutOrStdout())

                u.Step(1, 2, "Select Project")

                // Build menu options
                var menuOptions []string
                for _, p := range projects </span><span class="cov0" title="0">{
                        menuOptions = append(menuOptions, fmt.Sprintf("%s (#%d)", p.Title, p.Number))
                }</span>
                <span class="cov0" title="0">u.PrintMenu(menuOptions, true)

                // Get selection
                defaultSelection := "1"
                fmt.Fprint(cmd.OutOrStdout(), u.Prompt("Select", defaultSelection))
                selectionInput, _ := reader.ReadString('\n')
                selectionInput = strings.TrimSpace(selectionInput)

                if selectionInput == "" </span><span class="cov0" title="0">{
                        selectionInput = defaultSelection
                }</span>

                <span class="cov0" title="0">selection, err := strconv.Atoi(selectionInput)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid selection: %s", selectionInput)
                }</span>

                <span class="cov0" title="0">if selection == 0 </span><span class="cov0" title="0">{
                        // Manual entry
                        fmt.Fprint(cmd.OutOrStdout(), u.Prompt("Project number", ""))
                        numberInput, _ := reader.ReadString('\n')
                        numberInput = strings.TrimSpace(numberInput)
                        projectNumber, err = strconv.Atoi(numberInput)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("invalid project number: %s", numberInput)
                        }</span>

                        // Validate project exists
                        <span class="cov0" title="0">spinner = ui.NewSpinner(cmd.OutOrStdout(), fmt.Sprintf("Validating project %s/%d...", owner, projectNumber))
                        spinner.Start()
                        selectedProject, err = client.GetProject(owner, projectNumber)
                        spinner.Stop()

                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to find project: %w", err)
                        }</span>
                } else<span class="cov0" title="0"> if selection &lt; 1 || selection &gt; len(projects) </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid selection: must be between 0 and %d", len(projects))
                }</span> else<span class="cov0" title="0"> {
                        selectedProject = &amp;projects[selection-1]
                        projectNumber = selectedProject.Number
                }</span>

                <span class="cov0" title="0">u.Success(fmt.Sprintf("Project: %s (#%d)", selectedProject.Title, selectedProject.Number))</span>
        }

        // Step 2: Confirm repository
        <span class="cov0" title="0">fmt.Fprintln(cmd.OutOrStdout())
        u.Step(2, 2, "Confirm Repository")

        var repo string
        if defaultRepo != "" </span><span class="cov0" title="0">{
                fmt.Fprint(cmd.OutOrStdout(), u.Prompt("Repository", defaultRepo))
                repoInput, _ := reader.ReadString('\n')
                repoInput = strings.TrimSpace(repoInput)
                if repoInput != "" </span><span class="cov0" title="0">{
                        repo = repoInput
                }</span> else<span class="cov0" title="0"> {
                        repo = defaultRepo
                }</span>
        } else<span class="cov0" title="0"> {
                fmt.Fprint(cmd.OutOrStdout(), u.Prompt("Repository (owner/repo)", ""))
                repoInput, _ := reader.ReadString('\n')
                repo = strings.TrimSpace(repoInput)
        }</span>

        <span class="cov0" title="0">if repo == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("repository is required")
        }</span>

        <span class="cov0" title="0">u.Success(fmt.Sprintf("Repository: %s", repo))

        // Fetch project fields
        fmt.Fprintln(cmd.OutOrStdout())
        spinner = ui.NewSpinner(cmd.OutOrStdout(), "Fetching project fields...")
        spinner.Start()
        fields, err := client.GetProjectFields(selectedProject.ID)
        spinner.Stop()

        if err != nil </span><span class="cov0" title="0">{
                u.Warning(fmt.Sprintf("Could not fetch project fields: %v", err))
                fields = nil
        }</span>

        // Convert to metadata
        <span class="cov0" title="0">metadata := &amp;ProjectMetadata{
                ProjectID: selectedProject.ID,
        }
        for _, f := range fields </span><span class="cov0" title="0">{
                fm := FieldMetadata{
                        ID:       f.ID,
                        Name:     f.Name,
                        DataType: f.DataType,
                }
                for _, opt := range f.Options </span><span class="cov0" title="0">{
                        fm.Options = append(fm.Options, OptionMetadata{
                                ID:   opt.ID,
                                Name: opt.Name,
                        })
                }</span>
                <span class="cov0" title="0">metadata.Fields = append(metadata.Fields, fm)</span>
        }

        // Create config
        <span class="cov0" title="0">cfg := &amp;InitConfig{
                ProjectName:   selectedProject.Title,
                ProjectOwner:  owner,
                ProjectNumber: projectNumber,
                Repositories:  []string{repo},
        }

        // Write config
        cwd, _ := os.Getwd()
        if err := writeConfigWithMetadata(cwd, cfg, metadata); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write config: %w", err)
        }</span>

        // Print summary
        <span class="cov0" title="0">u.SummaryBox("Configuration saved", map[string]string{
                "Project":    fmt.Sprintf("%s (#%d)", selectedProject.Title, selectedProject.Number),
                "Repository": repo,
                "Fields":     fmt.Sprintf("%d cached", len(fields)),
                "Config":     ".gh-pmu.yml",
        }, []string{"Project", "Repository", "Fields", "Config"})

        return nil</span>
}

// parseGitRemote extracts owner/repo from a GitHub remote URL.
// Supports both HTTPS and SSH formats.
// Returns empty string if not a valid GitHub remote.
func parseGitRemote(remote string) string <span class="cov5" title="7">{
        if remote == "" </span><span class="cov1" title="1">{
                return ""
        }</span>

        // HTTPS format: https://github.com/owner/repo.git or https://github.com/owner/repo
        <span class="cov5" title="6">httpsRegex := regexp.MustCompile(`^https://github\.com/([^/]+)/([^/]+?)(?:\.git)?$`)
        if matches := httpsRegex.FindStringSubmatch(remote); matches != nil </span><span class="cov2" title="2">{
                return matches[1] + "/" + matches[2]
        }</span>

        // SSH format: git@github.com:owner/repo.git or git@github.com:owner/repo
        <span class="cov4" title="4">sshRegex := regexp.MustCompile(`^git@github\.com:([^/]+)/([^/]+?)(?:\.git)?$`)
        if matches := sshRegex.FindStringSubmatch(remote); matches != nil </span><span class="cov2" title="2">{
                return matches[1] + "/" + matches[2]
        }</span>

        <span class="cov2" title="2">return ""</span>
}

// detectRepository attempts to get the repository from git remote.
func detectRepository() string <span class="cov0" title="0">{
        // Try to get the origin remote URL
        cmd := exec.Command("git", "remote", "get-url", "origin")
        output, err := cmd.Output()
        if err != nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">return parseGitRemote(strings.TrimSpace(string(output)))</span>
}

// splitRepository splits "owner/repo" into owner and repo parts.
func splitRepository(repo string) (owner, name string) <span class="cov0" title="0">{
        parts := strings.SplitN(repo, "/", 2)
        if len(parts) == 2 </span><span class="cov0" title="0">{
                return parts[0], parts[1]
        }</span>
        <span class="cov0" title="0">return "", ""</span>
}

// InitConfig holds the configuration gathered during init.
type InitConfig struct {
        ProjectName   string
        ProjectOwner  string
        ProjectNumber int
        Repositories  []string
}

// ConfigFile represents the .gh-pmu.yml file structure.
type ConfigFile struct {
        Project      ProjectConfig           `yaml:"project"`
        Repositories []string                `yaml:"repositories"`
        Defaults     DefaultsConfig          `yaml:"defaults"`
        Fields       map[string]FieldMapping `yaml:"fields"`
        Triage       map[string]TriageRule   `yaml:"triage,omitempty"`
}

// ProjectConfig represents the project section of config.
type ProjectConfig struct {
        Name   string `yaml:"name,omitempty"`
        Number int    `yaml:"number"`
        Owner  string `yaml:"owner"`
}

// DefaultsConfig represents default values for new items.
type DefaultsConfig struct {
        Priority string   `yaml:"priority"`
        Status   string   `yaml:"status"`
        Labels   []string `yaml:"labels,omitempty"`
}

// FieldMapping represents a field alias mapping.
type FieldMapping struct {
        Field  string            `yaml:"field"`
        Values map[string]string `yaml:"values"`
}

// ProjectMetadata holds cached project information from GitHub API.
type ProjectMetadata struct {
        ProjectID string
        Fields    []FieldMetadata
}

// FieldMetadata holds cached field information.
type FieldMetadata struct {
        ID       string
        Name     string
        DataType string
        Options  []OptionMetadata
}

// OptionMetadata holds option information for single-select fields.
type OptionMetadata struct {
        ID   string
        Name string
}

// MetadataSection represents the metadata section in config file.
type MetadataSection struct {
        Project MetadataProject `yaml:"project"`
        Fields  []MetadataField `yaml:"fields"`
}

// MetadataProject holds the project ID.
type MetadataProject struct {
        ID string `yaml:"id"`
}

// MetadataField represents a field in the metadata section.
type MetadataField struct {
        Name     string                `yaml:"name"`
        ID       string                `yaml:"id"`
        DataType string                `yaml:"data_type"`
        Options  []MetadataFieldOption `yaml:"options,omitempty"`
}

// MetadataFieldOption represents a field option.
type MetadataFieldOption struct {
        Name string `yaml:"name"`
        ID   string `yaml:"id"`
}

// TriageRule represents a single triage rule configuration.
type TriageRule struct {
        Query       string          `yaml:"query"`
        Apply       TriageApply     `yaml:"apply"`
        Interactive map[string]bool `yaml:"interactive,omitempty"`
}

// TriageApply represents what to apply when a triage rule matches.
type TriageApply struct {
        Labels []string          `yaml:"labels,omitempty"`
        Fields map[string]string `yaml:"fields,omitempty"`
}

// ConfigFileWithMetadata extends ConfigFile with metadata section.
type ConfigFileWithMetadata struct {
        Project      ProjectConfig           `yaml:"project"`
        Repositories []string                `yaml:"repositories"`
        Defaults     DefaultsConfig          `yaml:"defaults"`
        Fields       map[string]FieldMapping `yaml:"fields"`
        Triage       map[string]TriageRule   `yaml:"triage,omitempty"`
        Metadata     MetadataSection         `yaml:"metadata"`
}

// ProjectValidator is the interface for validating projects.
type ProjectValidator interface {
        GetProject(owner string, number int) (interface{}, error)
}

// validateProject checks if the project exists.
func validateProject(client ProjectValidator, owner string, number int) error <span class="cov2" title="2">{
        _, err := client.GetProject(owner, number)
        return err
}</span>

// writeConfig writes the configuration to a .gh-pmu.yml file.
func writeConfig(dir string, cfg *InitConfig) error <span class="cov3" title="3">{
        configFile := &amp;ConfigFile{
                Project: ProjectConfig{
                        Name:   cfg.ProjectName,
                        Owner:  cfg.ProjectOwner,
                        Number: cfg.ProjectNumber,
                },
                Repositories: cfg.Repositories,
                Defaults: DefaultsConfig{
                        Priority: "p2",
                        Status:   "backlog",
                        Labels:   []string{"pm-tracked"},
                },
                Fields: map[string]FieldMapping{
                        "priority": {
                                Field: "Priority",
                                Values: map[string]string{
                                        "p0": "P0",
                                        "p1": "P1",
                                        "p2": "P2",
                                },
                        },
                        "status": {
                                Field: "Status",
                                Values: map[string]string{
                                        "backlog":     "Backlog",
                                        "ready":       "Ready",
                                        "in_progress": "In progress",
                                        "in_review":   "In review",
                                        "done":        "Done",
                                },
                        },
                },
                Triage: map[string]TriageRule{
                        "estimate": {
                                Query: "is:issue is:open -has:estimate",
                                Apply: TriageApply{},
                                Interactive: map[string]bool{
                                        "estimate": true,
                                },
                        },
                        "tracked": {
                                Query: "is:issue is:open -label:pm-tracked",
                                Apply: TriageApply{
                                        Labels: []string{"pm-tracked"},
                                        Fields: map[string]string{
                                                "priority": "p1",
                                                "status":   "backlog",
                                        },
                                },
                                Interactive: map[string]bool{
                                        "status": true,
                                },
                        },
                },
        }

        data, err := yaml.Marshal(configFile)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal config: %w", err)
        }</span>

        <span class="cov3" title="3">configPath := filepath.Join(dir, ".gh-pmu.yml")
        if err := os.WriteFile(configPath, data, 0644); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write config file: %w", err)
        }</span>

        <span class="cov3" title="3">return nil</span>
}

// writeConfigWithMetadata writes the configuration with project metadata.
func writeConfigWithMetadata(dir string, cfg *InitConfig, metadata *ProjectMetadata) error <span class="cov1" title="1">{
        // Convert metadata to YAML format
        var metadataFields []MetadataField
        for _, f := range metadata.Fields </span><span class="cov2" title="2">{
                mf := MetadataField{
                        Name:     f.Name,
                        ID:       f.ID,
                        DataType: f.DataType,
                }
                for _, opt := range f.Options </span><span class="cov4" title="4">{
                        mf.Options = append(mf.Options, MetadataFieldOption{
                                Name: opt.Name,
                                ID:   opt.ID,
                        })
                }</span>
                <span class="cov2" title="2">metadataFields = append(metadataFields, mf)</span>
        }

        <span class="cov1" title="1">configFile := &amp;ConfigFileWithMetadata{
                Project: ProjectConfig{
                        Name:   cfg.ProjectName,
                        Owner:  cfg.ProjectOwner,
                        Number: cfg.ProjectNumber,
                },
                Repositories: cfg.Repositories,
                Defaults: DefaultsConfig{
                        Priority: "p2",
                        Status:   "backlog",
                        Labels:   []string{"pm-tracked"},
                },
                Fields: map[string]FieldMapping{
                        "priority": {
                                Field: "Priority",
                                Values: map[string]string{
                                        "p0": "P0",
                                        "p1": "P1",
                                        "p2": "P2",
                                },
                        },
                        "status": {
                                Field: "Status",
                                Values: map[string]string{
                                        "backlog":     "Backlog",
                                        "ready":       "Ready",
                                        "in_progress": "In progress",
                                        "in_review":   "In review",
                                        "done":        "Done",
                                },
                        },
                },
                Triage: map[string]TriageRule{
                        "estimate": {
                                Query: "is:issue is:open -has:estimate",
                                Apply: TriageApply{},
                                Interactive: map[string]bool{
                                        "estimate": true,
                                },
                        },
                        "tracked": {
                                Query: "is:issue is:open -label:pm-tracked",
                                Apply: TriageApply{
                                        Labels: []string{"pm-tracked"},
                                        Fields: map[string]string{
                                                "priority": "p1",
                                                "status":   "backlog",
                                        },
                                },
                                Interactive: map[string]bool{
                                        "status": true,
                                },
                        },
                },
                Metadata: MetadataSection{
                        Project: MetadataProject{
                                ID: metadata.ProjectID,
                        },
                        Fields: metadataFields,
                },
        }

        data, err := yaml.Marshal(configFile)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal config: %w", err)
        }</span>

        <span class="cov1" title="1">configPath := filepath.Join(dir, ".gh-pmu.yml")
        if err := os.WriteFile(configPath, data, 0644); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write config file: %w", err)
        }</span>

        <span class="cov1" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package cmd

import (
        "encoding/json"
        "fmt"
        "os"
        "strings"
        "text/tabwriter"

        "github.com/scooter-indie/gh-pmu/internal/api"
        "github.com/scooter-indie/gh-pmu/internal/config"
        "github.com/spf13/cobra"
)

type intakeOptions struct {
        apply  bool
        dryRun bool
        json   bool
}

func newIntakeCommand() *cobra.Command <span class="cov10" title="53">{
        opts := &amp;intakeOptions{}

        cmd := &amp;cobra.Command{
                Use:   "intake",
                Short: "Find issues not yet added to the project",
                Long: `Find open issues in configured repositories that are not yet tracked in the project.

This helps ensure all work is captured on your project board.
Use --apply to automatically add discovered issues to the project.`,
                Aliases: []string{"in"},
                Example: `  # List untracked issues
  gh pmu intake

  # Preview what would be added
  gh pmu intake --dry-run

  # Add untracked issues to project
  gh pmu intake --apply

  # Output as JSON
  gh pmu intake --json`,
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        return runIntake(cmd, opts)
                }</span>,
        }

        <span class="cov10" title="53">cmd.Flags().BoolVarP(&amp;opts.apply, "apply", "a", false, "Add untracked issues to the project with default fields")
        cmd.Flags().BoolVar(&amp;opts.dryRun, "dry-run", false, "Show what would be added without making changes")
        cmd.Flags().BoolVar(&amp;opts.json, "json", false, "Output in JSON format")

        return cmd</span>
}

func runIntake(cmd *cobra.Command, opts *intakeOptions) error <span class="cov0" title="0">{
        // Load configuration
        cwd, err := os.Getwd()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get current directory: %w", err)
        }</span>

        <span class="cov0" title="0">cfg, err := config.LoadFromDirectory(cwd)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to load configuration: %w\nRun 'gh pmu init' to create a configuration file", err)
        }</span>

        <span class="cov0" title="0">if err := cfg.Validate(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid configuration: %w", err)
        }</span>

        <span class="cov0" title="0">if len(cfg.Repositories) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("no repositories configured in .gh-pmu.yml")
        }</span>

        // Create API client
        <span class="cov0" title="0">client := api.NewClient()

        // Get project
        project, err := client.GetProject(cfg.Project.Owner, cfg.Project.Number)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get project: %w", err)
        }</span>

        // Get all issues currently in the project
        <span class="cov0" title="0">projectItems, err := client.GetProjectItems(project.ID, nil)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get project items: %w", err)
        }</span>

        // Build set of issue IDs already in project
        <span class="cov0" title="0">trackedIssues := make(map[string]bool)
        for _, item := range projectItems </span><span class="cov0" title="0">{
                if item.Issue != nil </span><span class="cov0" title="0">{
                        trackedIssues[item.Issue.ID] = true
                }</span>
        }

        // Find untracked issues from each repository
        <span class="cov0" title="0">var untrackedIssues []api.Issue
        for _, repoFullName := range cfg.Repositories </span><span class="cov0" title="0">{
                parts := strings.SplitN(repoFullName, "/", 2)
                if len(parts) != 2 </span><span class="cov0" title="0">{
                        cmd.PrintErrf("Warning: invalid repository format %q, expected owner/repo\n", repoFullName)
                        continue</span>
                }
                <span class="cov0" title="0">owner, repo := parts[0], parts[1]

                // Get open issues from repository
                issues, err := client.GetRepositoryIssues(owner, repo, "open")
                if err != nil </span><span class="cov0" title="0">{
                        cmd.PrintErrf("Warning: failed to get issues from %s: %v\n", repoFullName, err)
                        continue</span>
                }

                // Filter to untracked issues
                <span class="cov0" title="0">for _, issue := range issues </span><span class="cov0" title="0">{
                        if !trackedIssues[issue.ID] </span><span class="cov0" title="0">{
                                issue.Repository = api.Repository{Owner: owner, Name: repo}
                                untrackedIssues = append(untrackedIssues, issue)
                        }</span>
                }
        }

        // Handle output
        <span class="cov0" title="0">if len(untrackedIssues) == 0 </span><span class="cov0" title="0">{
                if !opts.json </span><span class="cov0" title="0">{
                        cmd.Println("All issues are already tracked in the project")
                }</span> else<span class="cov0" title="0"> {
                        encoder := json.NewEncoder(os.Stdout)
                        encoder.SetIndent("", "  ")
                        _ = encoder.Encode(map[string]interface{}{"issues": []interface{}{}, "count": 0})
                }</span>
                <span class="cov0" title="0">return nil</span>
        }

        // Dry run - just show what would be added
        <span class="cov0" title="0">if opts.dryRun </span><span class="cov0" title="0">{
                if opts.json </span><span class="cov0" title="0">{
                        return outputIntakeJSON(cmd, untrackedIssues, "dry-run")
                }</span>
                <span class="cov0" title="0">cmd.Printf("Would add %d issue(s) to project:\n\n", len(untrackedIssues))
                return outputIntakeTable(cmd, untrackedIssues)</span>
        }

        // Apply - add issues to project
        <span class="cov0" title="0">if opts.apply </span><span class="cov0" title="0">{
                var added []api.Issue
                var failed []api.Issue

                for _, issue := range untrackedIssues </span><span class="cov0" title="0">{
                        itemID, err := client.AddIssueToProject(project.ID, issue.ID)
                        if err != nil </span><span class="cov0" title="0">{
                                cmd.PrintErrf("Failed to add #%d: %v\n", issue.Number, err)
                                failed = append(failed, issue)
                                continue</span>
                        }

                        // Apply default fields from config
                        <span class="cov0" title="0">if cfg.Defaults.Status != "" </span><span class="cov0" title="0">{
                                statusValue := cfg.ResolveFieldValue("status", cfg.Defaults.Status)
                                if err := client.SetProjectItemField(project.ID, itemID, "Status", statusValue); err != nil </span><span class="cov0" title="0">{
                                        cmd.PrintErrf("Warning: failed to set status on #%d: %v\n", issue.Number, err)
                                }</span>
                        }
                        <span class="cov0" title="0">if cfg.Defaults.Priority != "" </span><span class="cov0" title="0">{
                                priorityValue := cfg.ResolveFieldValue("priority", cfg.Defaults.Priority)
                                if err := client.SetProjectItemField(project.ID, itemID, "Priority", priorityValue); err != nil </span><span class="cov0" title="0">{
                                        cmd.PrintErrf("Warning: failed to set priority on #%d: %v\n", issue.Number, err)
                                }</span>
                        }

                        <span class="cov0" title="0">added = append(added, issue)</span>
                }

                <span class="cov0" title="0">if opts.json </span><span class="cov0" title="0">{
                        return outputIntakeJSON(cmd, added, "applied")
                }</span>

                <span class="cov0" title="0">cmd.Printf("Added %d issue(s) to project", len(added))
                if len(failed) &gt; 0 </span><span class="cov0" title="0">{
                        cmd.Printf(" (%d failed)", len(failed))
                }</span>
                <span class="cov0" title="0">cmd.Println()
                return nil</span>
        }

        // Default - just list untracked issues
        <span class="cov0" title="0">if opts.json </span><span class="cov0" title="0">{
                return outputIntakeJSON(cmd, untrackedIssues, "untracked")
        }</span>

        <span class="cov0" title="0">cmd.Printf("Found %d untracked issue(s):\n\n", len(untrackedIssues))
        if err := outputIntakeTable(cmd, untrackedIssues); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">cmd.Println("\nUse --apply to add these issues to the project")
        return nil</span>
}

func outputIntakeTable(cmd *cobra.Command, issues []api.Issue) error <span class="cov0" title="0">{
        w := tabwriter.NewWriter(os.Stdout, 0, 0, 2, ' ', 0)
        fmt.Fprintln(w, "NUMBER\tTITLE\tREPOSITORY\tSTATE")

        for _, issue := range issues </span><span class="cov0" title="0">{
                title := issue.Title
                if len(title) &gt; 50 </span><span class="cov0" title="0">{
                        title = title[:47] + "..."
                }</span>
                <span class="cov0" title="0">repoName := fmt.Sprintf("%s/%s", issue.Repository.Owner, issue.Repository.Name)
                fmt.Fprintf(w, "#%d\t%s\t%s\t%s\n", issue.Number, title, repoName, issue.State)</span>
        }

        <span class="cov0" title="0">return w.Flush()</span>
}

type intakeJSONOutput struct {
        Status string            `json:"status"`
        Count  int               `json:"count"`
        Issues []intakeJSONIssue `json:"issues"`
}

type intakeJSONIssue struct {
        Number     int    `json:"number"`
        Title      string `json:"title"`
        State      string `json:"state"`
        URL        string `json:"url"`
        Repository string `json:"repository"`
}

func outputIntakeJSON(cmd *cobra.Command, issues []api.Issue, status string) error <span class="cov0" title="0">{
        output := intakeJSONOutput{
                Status: status,
                Count:  len(issues),
                Issues: make([]intakeJSONIssue, 0, len(issues)),
        }

        for _, issue := range issues </span><span class="cov0" title="0">{
                output.Issues = append(output.Issues, intakeJSONIssue{
                        Number:     issue.Number,
                        Title:      issue.Title,
                        State:      issue.State,
                        URL:        issue.URL,
                        Repository: fmt.Sprintf("%s/%s", issue.Repository.Owner, issue.Repository.Name),
                })
        }</span>

        <span class="cov0" title="0">encoder := json.NewEncoder(os.Stdout)
        encoder.SetIndent("", "  ")
        return encoder.Encode(output)</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package cmd

import (
        "encoding/json"
        "fmt"
        "os"
        "strings"
        "text/tabwriter"

        "github.com/scooter-indie/gh-pmu/internal/api"
        "github.com/scooter-indie/gh-pmu/internal/config"
        "github.com/spf13/cobra"
)

type listOptions struct {
        status       string
        priority     string
        hasSubIssues bool
        json         bool
}

func newListCommand() *cobra.Command <span class="cov10" title="51">{
        opts := &amp;listOptions{}

        cmd := &amp;cobra.Command{
                Use:   "list",
                Short: "List issues from the configured project",
                Long: `List issues from the configured GitHub project with their field values.

By default, displays Title, Status, Priority, and Assignees for each issue.
Use filters to narrow down the results.`,
                Aliases: []string{"ls"},
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        return runList(cmd, opts)
                }</span>,
        }

        <span class="cov10" title="51">cmd.Flags().StringVarP(&amp;opts.status, "status", "s", "", "Filter by status (e.g., backlog, in_progress, done)")
        cmd.Flags().StringVarP(&amp;opts.priority, "priority", "p", "", "Filter by priority (e.g., p0, p1, p2)")
        cmd.Flags().BoolVar(&amp;opts.hasSubIssues, "has-sub-issues", false, "Filter to only show parent issues (issues with sub-issues)")
        cmd.Flags().BoolVar(&amp;opts.json, "json", false, "Output in JSON format")

        return cmd</span>
}

func runList(cmd *cobra.Command, opts *listOptions) error <span class="cov0" title="0">{
        // Load configuration from current directory
        cwd, err := os.Getwd()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get current directory: %w", err)
        }</span>

        <span class="cov0" title="0">cfg, err := config.LoadFromDirectory(cwd)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to load configuration: %w\nRun 'gh pmu init' to create a configuration file", err)
        }</span>

        // Validate config
        <span class="cov0" title="0">if err := cfg.Validate(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid configuration: %w", err)
        }</span>

        // Create API client
        <span class="cov0" title="0">client := api.NewClient()

        // Get project
        project, err := client.GetProject(cfg.Project.Owner, cfg.Project.Number)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get project: %w", err)
        }</span>

        // Build filter
        <span class="cov0" title="0">var filter *api.ProjectItemsFilter
        if len(cfg.Repositories) &gt; 0 </span><span class="cov0" title="0">{
                filter = &amp;api.ProjectItemsFilter{
                        Repository: cfg.Repositories[0],
                }
        }</span>

        // Fetch project items
        <span class="cov0" title="0">items, err := client.GetProjectItems(project.ID, filter)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get project items: %w", err)
        }</span>

        // Apply status filter
        <span class="cov0" title="0">if opts.status != "" </span><span class="cov0" title="0">{
                targetStatus := cfg.ResolveFieldValue("status", opts.status)
                items = filterByFieldValue(items, "Status", targetStatus)
        }</span>

        // Apply priority filter
        <span class="cov0" title="0">if opts.priority != "" </span><span class="cov0" title="0">{
                targetPriority := cfg.ResolveFieldValue("priority", opts.priority)
                items = filterByFieldValue(items, "Priority", targetPriority)
        }</span>

        // Apply has-sub-issues filter
        <span class="cov0" title="0">if opts.hasSubIssues </span><span class="cov0" title="0">{
                items = filterByHasSubIssues(client, items)
        }</span>

        // Output
        <span class="cov0" title="0">if opts.json </span><span class="cov0" title="0">{
                return outputJSON(cmd, items)
        }</span>

        <span class="cov0" title="0">return outputTable(cmd, items)</span>
}

// filterByFieldValue filters items by a specific field value
func filterByFieldValue(items []api.ProjectItem, fieldName, value string) []api.ProjectItem <span class="cov0" title="0">{
        var filtered []api.ProjectItem
        for _, item := range items </span><span class="cov0" title="0">{
                for _, fv := range item.FieldValues </span><span class="cov0" title="0">{
                        if strings.EqualFold(fv.Field, fieldName) &amp;&amp; strings.EqualFold(fv.Value, value) </span><span class="cov0" title="0">{
                                filtered = append(filtered, item)
                                break</span>
                        }
                }
        }
        <span class="cov0" title="0">return filtered</span>
}

// filterByHasSubIssues filters items to only those with sub-issues
func filterByHasSubIssues(client *api.Client, items []api.ProjectItem) []api.ProjectItem <span class="cov0" title="0">{
        var filtered []api.ProjectItem
        for _, item := range items </span><span class="cov0" title="0">{
                if item.Issue == nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Check if issue has sub-issues
                <span class="cov0" title="0">subIssues, err := client.GetSubIssues(
                        item.Issue.Repository.Owner,
                        item.Issue.Repository.Name,
                        item.Issue.Number,
                )
                if err != nil </span><span class="cov0" title="0">{
                        // Skip issues where we can't fetch sub-issues
                        continue</span>
                }

                <span class="cov0" title="0">if len(subIssues) &gt; 0 </span><span class="cov0" title="0">{
                        filtered = append(filtered, item)
                }</span>
        }
        <span class="cov0" title="0">return filtered</span>
}

// getFieldValue gets a field value from an item
func getFieldValue(item api.ProjectItem, fieldName string) string <span class="cov0" title="0">{
        for _, fv := range item.FieldValues </span><span class="cov0" title="0">{
                if strings.EqualFold(fv.Field, fieldName) </span><span class="cov0" title="0">{
                        return fv.Value
                }</span>
        }
        <span class="cov0" title="0">return ""</span>
}

// outputTable outputs items in a table format
func outputTable(cmd *cobra.Command, items []api.ProjectItem) error <span class="cov0" title="0">{
        if len(items) == 0 </span><span class="cov0" title="0">{
                cmd.Println("No issues found")
                return nil
        }</span>

        <span class="cov0" title="0">w := tabwriter.NewWriter(os.Stdout, 0, 0, 2, ' ', 0)
        fmt.Fprintln(w, "NUMBER\tTITLE\tSTATUS\tPRIORITY\tASSIGNEES")

        for _, item := range items </span><span class="cov0" title="0">{
                if item.Issue == nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Get field values
                <span class="cov0" title="0">status := getFieldValue(item, "Status")
                priority := getFieldValue(item, "Priority")

                // Format assignees
                var assignees []string
                for _, a := range item.Issue.Assignees </span><span class="cov0" title="0">{
                        assignees = append(assignees, a.Login)
                }</span>
                <span class="cov0" title="0">assigneeStr := strings.Join(assignees, ", ")
                if assigneeStr == "" </span><span class="cov0" title="0">{
                        assigneeStr = "-"
                }</span>

                // Truncate title if too long
                <span class="cov0" title="0">title := item.Issue.Title
                if len(title) &gt; 50 </span><span class="cov0" title="0">{
                        title = title[:47] + "..."
                }</span>

                <span class="cov0" title="0">fmt.Fprintf(w, "#%d\t%s\t%s\t%s\t%s\n",
                        item.Issue.Number,
                        title,
                        status,
                        priority,
                        assigneeStr,
                )</span>
        }

        <span class="cov0" title="0">w.Flush()
        return nil</span>
}

// JSONOutput represents the JSON output structure
type JSONOutput struct {
        Items []JSONItem `json:"items"`
}

// JSONItem represents an item in JSON output
type JSONItem struct {
        Number      int               `json:"number"`
        Title       string            `json:"title"`
        State       string            `json:"state"`
        URL         string            `json:"url"`
        Repository  string            `json:"repository"`
        Assignees   []string          `json:"assignees"`
        FieldValues map[string]string `json:"fieldValues"`
}

// outputJSON outputs items in JSON format
func outputJSON(cmd *cobra.Command, items []api.ProjectItem) error <span class="cov0" title="0">{
        output := JSONOutput{
                Items: make([]JSONItem, 0, len(items)),
        }

        for _, item := range items </span><span class="cov0" title="0">{
                if item.Issue == nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">jsonItem := JSONItem{
                        Number:      item.Issue.Number,
                        Title:       item.Issue.Title,
                        State:       item.Issue.State,
                        URL:         item.Issue.URL,
                        Repository:  fmt.Sprintf("%s/%s", item.Issue.Repository.Owner, item.Issue.Repository.Name),
                        Assignees:   make([]string, 0),
                        FieldValues: make(map[string]string),
                }

                for _, a := range item.Issue.Assignees </span><span class="cov0" title="0">{
                        jsonItem.Assignees = append(jsonItem.Assignees, a.Login)
                }</span>

                <span class="cov0" title="0">for _, fv := range item.FieldValues </span><span class="cov0" title="0">{
                        jsonItem.FieldValues[fv.Field] = fv.Value
                }</span>

                <span class="cov0" title="0">output.Items = append(output.Items, jsonItem)</span>
        }

        <span class="cov0" title="0">encoder := json.NewEncoder(os.Stdout)
        encoder.SetIndent("", "  ")
        return encoder.Encode(output)</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package cmd

import (
        "fmt"
        "os"
        "strings"

        "github.com/scooter-indie/gh-pmu/internal/api"
        "github.com/scooter-indie/gh-pmu/internal/config"
        "github.com/spf13/cobra"
)

type moveOptions struct {
        status    string
        priority  string
        recursive bool
        depth     int
        dryRun    bool
        yes       bool // skip confirmation
}

func newMoveCommand() *cobra.Command <span class="cov10" title="51">{
        opts := &amp;moveOptions{
                depth: 10, // default max depth
        }

        cmd := &amp;cobra.Command{
                Use:   "move &lt;issue-number&gt;",
                Short: "Update project fields for an issue",
                Long: `Update project field values for an issue.

Changes the status, priority, or other project fields for an issue
that is already in the configured project.

Field values are resolved through config aliases, so you can use
shorthand values like "in_progress" which will be mapped to "In Progress".

Use --recursive to update all sub-issues as well. This will traverse
the issue tree and apply the same changes to all descendants.`,
                Args: cobra.ExactArgs(1),
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov1" title="1">{
                        return runMove(cmd, args, opts)
                }</span>,
        }

        <span class="cov10" title="51">cmd.Flags().StringVarP(&amp;opts.status, "status", "s", "", "Set project status field")
        cmd.Flags().StringVarP(&amp;opts.priority, "priority", "p", "", "Set project priority field")
        cmd.Flags().BoolVarP(&amp;opts.recursive, "recursive", "r", false, "Apply changes to all sub-issues recursively")
        cmd.Flags().IntVar(&amp;opts.depth, "depth", 10, "Maximum depth for recursive operations")
        cmd.Flags().BoolVar(&amp;opts.dryRun, "dry-run", false, "Show what would be changed without making changes")
        cmd.Flags().BoolVarP(&amp;opts.yes, "yes", "y", false, "Skip confirmation prompt for recursive operations")

        return cmd</span>
}

// issueInfo holds information about an issue to be updated
type issueInfo struct {
        Owner  string
        Repo   string
        Number int
        Title  string
        ItemID string
        Depth  int
}

func runMove(cmd *cobra.Command, args []string, opts *moveOptions) error <span class="cov1" title="1">{
        // Validate at least one flag is provided
        if opts.status == "" &amp;&amp; opts.priority == "" </span><span class="cov1" title="1">{
                return fmt.Errorf("at least one of --status or --priority is required")
        }</span>

        // Load configuration
        <span class="cov0" title="0">cwd, err := os.Getwd()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get current directory: %w", err)
        }</span>

        <span class="cov0" title="0">cfg, err := config.LoadFromDirectory(cwd)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to load configuration: %w\nRun 'gh pmu init' to create a configuration file", err)
        }</span>

        <span class="cov0" title="0">if err := cfg.Validate(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid configuration: %w", err)
        }</span>

        // Parse issue reference
        <span class="cov0" title="0">owner, repo, number, err := parseIssueReference(args[0])
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // If owner/repo not specified, use first repo from config
        <span class="cov0" title="0">if owner == "" || repo == "" </span><span class="cov0" title="0">{
                if len(cfg.Repositories) == 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("no repository specified and none configured")
                }</span>
                <span class="cov0" title="0">parts := strings.Split(cfg.Repositories[0], "/")
                if len(parts) != 2 </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid repository format in config: %s", cfg.Repositories[0])
                }</span>
                <span class="cov0" title="0">owner = parts[0]
                repo = parts[1]</span>
        }

        // Create API client
        <span class="cov0" title="0">client := api.NewClient()

        // Get issue to verify it exists
        issue, err := client.GetIssue(owner, repo, number)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get issue: %w", err)
        }</span>

        // Get project
        <span class="cov0" title="0">project, err := client.GetProject(cfg.Project.Owner, cfg.Project.Number)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get project: %w", err)
        }</span>

        // Find the project item ID for this issue
        <span class="cov0" title="0">items, err := client.GetProjectItems(project.ID, nil)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get project items: %w", err)
        }</span>

        // Build a map of issue numbers to item IDs for quick lookup
        <span class="cov0" title="0">itemIDMap := make(map[string]string) // "owner/repo#number" -&gt; itemID
        for _, item := range items </span><span class="cov0" title="0">{
                if item.Issue != nil </span><span class="cov0" title="0">{
                        key := fmt.Sprintf("%s/%s#%d", item.Issue.Repository.Owner, item.Issue.Repository.Name, item.Issue.Number)
                        itemIDMap[key] = item.ID
                }</span>
        }

        <span class="cov0" title="0">rootKey := fmt.Sprintf("%s/%s#%d", owner, repo, number)
        rootItemID, inProject := itemIDMap[rootKey]
        if !inProject </span><span class="cov0" title="0">{
                return fmt.Errorf("issue #%d is not in the project", number)
        }</span>

        // Collect all issues to update
        <span class="cov0" title="0">issuesToUpdate := []issueInfo{{
                Owner:  owner,
                Repo:   repo,
                Number: number,
                Title:  issue.Title,
                ItemID: rootItemID,
                Depth:  0,
        }}

        // If recursive, collect all sub-issues
        if opts.recursive </span><span class="cov0" title="0">{
                subIssues, err := collectSubIssuesRecursive(client, owner, repo, number, itemIDMap, 1, opts.depth)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to collect sub-issues: %w", err)
                }</span>
                <span class="cov0" title="0">issuesToUpdate = append(issuesToUpdate, subIssues...)</span>
        }

        // Resolve field values
        <span class="cov0" title="0">statusValue := ""
        priorityValue := ""
        var changeDescriptions []string

        if opts.status != "" </span><span class="cov0" title="0">{
                statusValue = cfg.ResolveFieldValue("status", opts.status)
                changeDescriptions = append(changeDescriptions, fmt.Sprintf("Status  %s", statusValue))
        }</span>
        <span class="cov0" title="0">if opts.priority != "" </span><span class="cov0" title="0">{
                priorityValue = cfg.ResolveFieldValue("priority", opts.priority)
                changeDescriptions = append(changeDescriptions, fmt.Sprintf("Priority  %s", priorityValue))
        }</span>

        // Show what will be updated
        <span class="cov0" title="0">if opts.recursive || opts.dryRun </span><span class="cov0" title="0">{
                if opts.dryRun </span><span class="cov0" title="0">{
                        fmt.Println("Dry run - no changes will be made")
                        fmt.Println()
                }</span>

                <span class="cov0" title="0">fmt.Printf("Issues to update (%d):\n", len(issuesToUpdate))
                for _, info := range issuesToUpdate </span><span class="cov0" title="0">{
                        indent := strings.Repeat("  ", info.Depth)
                        if info.ItemID != "" </span><span class="cov0" title="0">{
                                fmt.Printf("%s #%d - %s\n", indent, info.Number, info.Title)
                        }</span> else<span class="cov0" title="0"> {
                                fmt.Printf("%s #%d - %s (not in project, will skip)\n", indent, info.Number, info.Title)
                        }</span>
                }

                <span class="cov0" title="0">fmt.Println("\nChanges to apply:")
                for _, desc := range changeDescriptions </span><span class="cov0" title="0">{
                        fmt.Printf("   %s\n", desc)
                }</span>

                <span class="cov0" title="0">if opts.dryRun </span><span class="cov0" title="0">{
                        return nil
                }</span>

                // Prompt for confirmation unless --yes is provided
                <span class="cov0" title="0">if !opts.yes </span><span class="cov0" title="0">{
                        fmt.Printf("\nProceed with updating %d issues? [y/N]: ", len(issuesToUpdate))
                        var response string
                        _, _ = fmt.Scanln(&amp;response)
                        response = strings.ToLower(strings.TrimSpace(response))
                        if response != "y" &amp;&amp; response != "yes" </span><span class="cov0" title="0">{
                                fmt.Println("Aborted.")
                                return nil
                        }</span>
                }
                <span class="cov0" title="0">fmt.Println()</span>
        }

        // Apply updates
        <span class="cov0" title="0">updatedCount := 0
        skippedCount := 0

        for _, info := range issuesToUpdate </span><span class="cov0" title="0">{
                if info.ItemID == "" </span><span class="cov0" title="0">{
                        skippedCount++
                        continue</span>
                }

                // Update status if provided
                <span class="cov0" title="0">if statusValue != "" </span><span class="cov0" title="0">{
                        if err := client.SetProjectItemField(project.ID, info.ItemID, "Status", statusValue); err != nil </span><span class="cov0" title="0">{
                                fmt.Fprintf(os.Stderr, "Warning: failed to set status for #%d: %v\n", info.Number, err)
                                continue</span>
                        }
                }

                // Update priority if provided
                <span class="cov0" title="0">if priorityValue != "" </span><span class="cov0" title="0">{
                        if err := client.SetProjectItemField(project.ID, info.ItemID, "Priority", priorityValue); err != nil </span><span class="cov0" title="0">{
                                fmt.Fprintf(os.Stderr, "Warning: failed to set priority for #%d: %v\n", info.Number, err)
                                continue</span>
                        }
                }

                <span class="cov0" title="0">updatedCount++
                if !opts.recursive </span><span class="cov0" title="0">{
                        // Single issue - show detailed output
                        fmt.Printf(" Updated issue #%d: %s\n", info.Number, info.Title)
                        for _, desc := range changeDescriptions </span><span class="cov0" title="0">{
                                fmt.Printf("   %s\n", desc)
                        }</span>
                        <span class="cov0" title="0">fmt.Printf(" https://github.com/%s/%s/issues/%d\n", info.Owner, info.Repo, info.Number)</span>
                }
        }

        // Summary for recursive operations
        <span class="cov0" title="0">if opts.recursive </span><span class="cov0" title="0">{
                fmt.Printf(" Updated %d issues", updatedCount)
                if skippedCount &gt; 0 </span><span class="cov0" title="0">{
                        fmt.Printf(" (%d skipped - not in project)", skippedCount)
                }</span>
                <span class="cov0" title="0">fmt.Println()</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// collectSubIssuesRecursive recursively collects all sub-issues up to maxDepth
func collectSubIssuesRecursive(client *api.Client, owner, repo string, number int, itemIDMap map[string]string, currentDepth, maxDepth int) ([]issueInfo, error) <span class="cov0" title="0">{
        if currentDepth &gt; maxDepth </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        <span class="cov0" title="0">subIssues, err := client.GetSubIssues(owner, repo, number)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var result []issueInfo
        for _, sub := range subIssues </span><span class="cov0" title="0">{
                // Determine the repo for this sub-issue
                subOwner := sub.Repository.Owner
                subRepo := sub.Repository.Name
                if subOwner == "" </span><span class="cov0" title="0">{
                        subOwner = owner
                }</span>
                <span class="cov0" title="0">if subRepo == "" </span><span class="cov0" title="0">{
                        subRepo = repo
                }</span>

                <span class="cov0" title="0">key := fmt.Sprintf("%s/%s#%d", subOwner, subRepo, sub.Number)
                itemID := itemIDMap[key] // may be empty if not in project

                info := issueInfo{
                        Owner:  subOwner,
                        Repo:   subRepo,
                        Number: sub.Number,
                        Title:  sub.Title,
                        ItemID: itemID,
                        Depth:  currentDepth,
                }
                result = append(result, info)

                // Recurse into this sub-issue's children
                children, err := collectSubIssuesRecursive(client, subOwner, subRepo, sub.Number, itemIDMap, currentDepth+1, maxDepth)
                if err != nil </span><span class="cov0" title="0">{
                        // Log warning but continue
                        fmt.Fprintf(os.Stderr, "Warning: failed to get sub-issues for #%d: %v\n", sub.Number, err)
                        continue</span>
                }
                <span class="cov0" title="0">result = append(result, children...)</span>
        }

        <span class="cov0" title="0">return result, nil</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package cmd

import (
        "github.com/spf13/cobra"
)

var version = "dev"

func NewRootCommand() *cobra.Command <span class="cov10" title="51">{
        cmd := &amp;cobra.Command{
                Use:   "gh-pmu",
                Short: "GitHub Project Management CLI (Unified)",
                Long: `gh-pmu is a unified GitHub CLI extension for project management, sub-issue hierarchy, and project templating.

This extension combines and replaces:
  - gh-pm (https://github.com/yahsan2/gh-pm) - Project management
  - gh-sub-issue (https://github.com/yahsan2/gh-sub-issue) - Sub-issue hierarchy

Use 'gh pmu &lt;command&gt; --help' for more information about a command.`,
                Version: version,
        }

        cmd.AddCommand(newInitCommand())
        cmd.AddCommand(newListCommand())
        cmd.AddCommand(newViewCommand())
        cmd.AddCommand(newCreateCommand())
        cmd.AddCommand(newMoveCommand())
        cmd.AddCommand(newSubCommand())
        cmd.AddCommand(newIntakeCommand())
        cmd.AddCommand(newTriageCommand())
        cmd.AddCommand(newSplitCommand())

        return cmd
}</span>

func Execute() error <span class="cov0" title="0">{
        return NewRootCommand().Execute()
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package cmd

import (
        "encoding/json"
        "fmt"
        "os"
        "regexp"
        "strconv"
        "strings"

        "github.com/scooter-indie/gh-pmu/internal/api"
        "github.com/scooter-indie/gh-pmu/internal/config"
        "github.com/spf13/cobra"
)

type splitOptions struct {
        from   string
        dryRun bool
        json   bool
}

func newSplitCommand() *cobra.Command <span class="cov10" title="53">{
        opts := &amp;splitOptions{}

        cmd := &amp;cobra.Command{
                Use:   "split &lt;issue&gt; [tasks...]",
                Short: "Split an issue into sub-issues",
                Long: `Split an issue into multiple sub-issues from a checklist or arguments.

The checklist can come from:
- The issue body (--from=body)
- An external file (--from=path/to/file.md)
- Command line arguments (gh pmu split 123 "Task 1" "Task 2")

Only unchecked items (- [ ]) are converted to sub-issues.
Completed items (- [x]) are skipped.`,
                Example: `  # Split from issue body checklist
  gh pmu split 123 --from=body

  # Split from external file
  gh pmu split 123 --from=tasks.md

  # Split from command line arguments
  gh pmu split 123 "Implement feature A" "Implement feature B" "Write tests"

  # Preview without creating
  gh pmu split 123 --from=body --dry-run`,
                Args: cobra.MinimumNArgs(1),
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        return runSplit(cmd, args, opts)
                }</span>,
        }

        <span class="cov10" title="53">cmd.Flags().StringVar(&amp;opts.from, "from", "", "Source for tasks: 'body' (issue body) or file path")
        cmd.Flags().BoolVar(&amp;opts.dryRun, "dry-run", false, "Show what would be created without making changes")
        cmd.Flags().BoolVar(&amp;opts.json, "json", false, "Output in JSON format")

        return cmd</span>
}

func runSplit(cmd *cobra.Command, args []string, opts *splitOptions) error <span class="cov0" title="0">{
        // Parse issue number
        issueNum, err := strconv.Atoi(args[0])
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid issue number: %s", args[0])
        }</span>

        // Load configuration
        <span class="cov0" title="0">cwd, err := os.Getwd()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get current directory: %w", err)
        }</span>

        <span class="cov0" title="0">cfg, err := config.LoadFromDirectory(cwd)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to load configuration: %w\nRun 'gh pmu init' to create a configuration file", err)
        }</span>

        <span class="cov0" title="0">if err := cfg.Validate(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid configuration: %w", err)
        }</span>

        <span class="cov0" title="0">if len(cfg.Repositories) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("no repositories configured in .gh-pmu.yml")
        }</span>

        // Parse repository
        <span class="cov0" title="0">repoParts := strings.SplitN(cfg.Repositories[0], "/", 2)
        if len(repoParts) != 2 </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid repository format: %s", cfg.Repositories[0])
        }</span>
        <span class="cov0" title="0">owner, repo := repoParts[0], repoParts[1]

        // Create API client
        client := api.NewClient()

        // Get the parent issue
        parentIssue, err := client.GetIssue(owner, repo, issueNum)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get issue #%d: %w", issueNum, err)
        }</span>

        // Determine tasks to create
        <span class="cov0" title="0">var tasks []string

        if opts.from != "" </span><span class="cov0" title="0">{
                if opts.from == "body" </span><span class="cov0" title="0">{
                        // Parse from issue body
                        tasks = parseChecklist(parentIssue.Body)
                }</span> else<span class="cov0" title="0"> {
                        // Parse from file
                        content, err := os.ReadFile(opts.from)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to read file %s: %w", opts.from, err)
                        }</span>
                        <span class="cov0" title="0">tasks = parseChecklist(string(content))</span>
                }
        } else<span class="cov0" title="0"> if len(args) &gt; 1 </span><span class="cov0" title="0">{
                // Tasks from command line arguments
                tasks = args[1:]
        }</span> else<span class="cov0" title="0"> {
                return fmt.Errorf("no tasks specified\nUse --from=body, --from=&lt;file&gt;, or provide tasks as arguments")
        }</span>

        <span class="cov0" title="0">if len(tasks) == 0 </span><span class="cov0" title="0">{
                if opts.json </span><span class="cov0" title="0">{
                        return outputSplitJSON(cmd, parentIssue, nil, "no-tasks")
                }</span>
                <span class="cov0" title="0">cmd.Println("No tasks found to create as sub-issues")
                return nil</span>
        }

        // Dry run - just show what would be created
        <span class="cov0" title="0">if opts.dryRun </span><span class="cov0" title="0">{
                if opts.json </span><span class="cov0" title="0">{
                        return outputSplitJSON(cmd, parentIssue, tasks, "dry-run")
                }</span>
                <span class="cov0" title="0">cmd.Printf("Would create %d sub-issue(s) under #%d: %s\n\n", len(tasks), parentIssue.Number, parentIssue.Title)
                for i, task := range tasks </span><span class="cov0" title="0">{
                        cmd.Printf("  %d. %s\n", i+1, task)
                }</span>
                <span class="cov0" title="0">return nil</span>
        }

        // Create sub-issues
        <span class="cov0" title="0">var created []api.Issue
        var failed []string

        for _, task := range tasks </span><span class="cov0" title="0">{
                // Create the issue
                newIssue, err := client.CreateIssue(owner, repo, task, "", nil)
                if err != nil </span><span class="cov0" title="0">{
                        cmd.PrintErrf("Failed to create sub-issue %q: %v\n", task, err)
                        failed = append(failed, task)
                        continue</span>
                }

                // Link as sub-issue
                <span class="cov0" title="0">err = client.AddSubIssue(parentIssue.ID, newIssue.ID)
                if err != nil </span><span class="cov0" title="0">{
                        cmd.PrintErrf("Created #%d but failed to link as sub-issue: %v\n", newIssue.Number, err)
                        // Still count as created since issue exists
                }</span>

                <span class="cov0" title="0">created = append(created, *newIssue)
                cmd.Printf("Created sub-issue #%d: %s\n", newIssue.Number, newIssue.Title)</span>
        }

        // Summary
        <span class="cov0" title="0">if opts.json </span><span class="cov0" title="0">{
                return outputSplitJSONCreated(cmd, parentIssue, created, failed)
        }</span>

        <span class="cov0" title="0">cmd.Printf("\nSplit complete: %d sub-issue(s) created under #%d", len(created), parentIssue.Number)
        if len(failed) &gt; 0 </span><span class="cov0" title="0">{
                cmd.Printf(" (%d failed)", len(failed))
        }</span>
        <span class="cov0" title="0">cmd.Println()

        return nil</span>
}

// parseChecklist extracts unchecked checklist items from markdown text
func parseChecklist(text string) []string <span class="cov4" title="5">{
        var tasks []string

        // Match unchecked checklist items: - [ ] Task text
        // Regex: starts with - [ ] followed by whitespace and task text
        re := regexp.MustCompile(`(?m)^[\s]*-\s*\[\s*\]\s*(.+)$`)

        matches := re.FindAllStringSubmatch(text, -1)
        for _, match := range matches </span><span class="cov5" title="9">{
                if len(match) &gt; 1 </span><span class="cov5" title="9">{
                        task := strings.TrimSpace(match[1])
                        if task != "" </span><span class="cov5" title="9">{
                                tasks = append(tasks, task)
                        }</span>
                }
        }

        <span class="cov4" title="5">return tasks</span>
}

func outputSplitJSON(cmd *cobra.Command, parent *api.Issue, tasks []string, status string) error <span class="cov0" title="0">{
        output := map[string]interface{}{
                "status": status,
                "parent": map[string]interface{}{
                        "number": parent.Number,
                        "title":  parent.Title,
                        "url":    parent.URL,
                },
                "taskCount": len(tasks),
                "tasks":     tasks,
        }

        encoder := json.NewEncoder(os.Stdout)
        encoder.SetIndent("", "  ")
        return encoder.Encode(output)
}</span>

func outputSplitJSONCreated(cmd *cobra.Command, parent *api.Issue, created []api.Issue, failed []string) error <span class="cov0" title="0">{
        createdJSON := make([]map[string]interface{}, 0, len(created))
        for _, issue := range created </span><span class="cov0" title="0">{
                createdJSON = append(createdJSON, map[string]interface{}{
                        "number": issue.Number,
                        "title":  issue.Title,
                        "url":    issue.URL,
                })
        }</span>

        <span class="cov0" title="0">output := map[string]interface{}{
                "status": "completed",
                "parent": map[string]interface{}{
                        "number": parent.Number,
                        "title":  parent.Title,
                        "url":    parent.URL,
                },
                "createdCount": len(created),
                "failedCount":  len(failed),
                "created":      createdJSON,
                "failed":       failed,
        }

        encoder := json.NewEncoder(os.Stdout)
        encoder.SetIndent("", "  ")
        return encoder.Encode(output)</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package cmd

import (
        "encoding/json"
        "fmt"
        "os"
        "strings"

        "github.com/scooter-indie/gh-pmu/internal/api"
        "github.com/scooter-indie/gh-pmu/internal/config"
        "github.com/spf13/cobra"
)

func newSubCommand() *cobra.Command <span class="cov10" title="51">{
        cmd := &amp;cobra.Command{
                Use:   "sub",
                Short: "Manage sub-issues",
                Long: `Manage sub-issue relationships between issues.

Sub-issues allow you to create parent-child hierarchies between issues,
useful for breaking down epics into smaller tasks.`,
        }

        cmd.AddCommand(newSubAddCommand())
        cmd.AddCommand(newSubCreateCommand())
        cmd.AddCommand(newSubListCommand())
        cmd.AddCommand(newSubRemoveCommand())

        return cmd
}</span>

func newSubAddCommand() *cobra.Command <span class="cov10" title="51">{
        cmd := &amp;cobra.Command{
                Use:   "add &lt;parent-issue&gt; &lt;child-issue&gt;",
                Short: "Link an issue as a sub-issue of another",
                Long: `Link an existing issue as a sub-issue of a parent issue.

Both issues must already exist. The child issue will appear as a
sub-issue under the parent issue in GitHub's UI.

Examples:
  gh pmu sub add 10 15        # Link issue #15 as sub-issue of #10
  gh pmu sub add #10 #15      # Same, with # prefix
  gh pmu sub add owner/repo#10 owner/repo#15  # Full references`,
                Args: cobra.ExactArgs(2),
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        return runSubAdd(cmd, args)
                }</span>,
        }

        <span class="cov10" title="51">return cmd</span>
}

func runSubAdd(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
        // Load configuration
        cwd, err := os.Getwd()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get current directory: %w", err)
        }</span>

        <span class="cov0" title="0">cfg, err := config.LoadFromDirectory(cwd)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to load configuration: %w\nRun 'gh pmu init' to create a configuration file", err)
        }</span>

        <span class="cov0" title="0">if err := cfg.Validate(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid configuration: %w", err)
        }</span>

        // Parse parent issue reference
        <span class="cov0" title="0">parentOwner, parentRepo, parentNumber, err := parseIssueReference(args[0])
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid parent issue: %w", err)
        }</span>

        // Parse child issue reference
        <span class="cov0" title="0">childOwner, childRepo, childNumber, err := parseIssueReference(args[1])
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid child issue: %w", err)
        }</span>

        // Default to configured repo if not specified
        <span class="cov0" title="0">if parentOwner == "" || parentRepo == "" </span><span class="cov0" title="0">{
                if len(cfg.Repositories) == 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("no repository specified and none configured")
                }</span>
                <span class="cov0" title="0">parts := strings.Split(cfg.Repositories[0], "/")
                if len(parts) != 2 </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid repository format in config: %s", cfg.Repositories[0])
                }</span>
                <span class="cov0" title="0">parentOwner = parts[0]
                parentRepo = parts[1]</span>
        }

        <span class="cov0" title="0">if childOwner == "" || childRepo == "" </span><span class="cov0" title="0">{
                if len(cfg.Repositories) == 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("no repository specified and none configured")
                }</span>
                <span class="cov0" title="0">parts := strings.Split(cfg.Repositories[0], "/")
                if len(parts) != 2 </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid repository format in config: %s", cfg.Repositories[0])
                }</span>
                <span class="cov0" title="0">childOwner = parts[0]
                childRepo = parts[1]</span>
        }

        // Create API client
        <span class="cov0" title="0">client := api.NewClient()

        // Validate parent issue exists
        parentIssue, err := client.GetIssue(parentOwner, parentRepo, parentNumber)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get parent issue #%d: %w", parentNumber, err)
        }</span>

        // Validate child issue exists
        <span class="cov0" title="0">childIssue, err := client.GetIssue(childOwner, childRepo, childNumber)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get child issue #%d: %w", childNumber, err)
        }</span>

        // Add sub-issue link
        <span class="cov0" title="0">err = client.AddSubIssue(parentIssue.ID, childIssue.ID)
        if err != nil </span><span class="cov0" title="0">{
                // Check if already linked (GitHub returns "duplicate" or "only have one parent" messages)
                errMsg := strings.ToLower(err.Error())
                if strings.Contains(errMsg, "duplicate") || strings.Contains(errMsg, "only have one parent") </span><span class="cov0" title="0">{
                        return fmt.Errorf("issue #%d is already a sub-issue (issues can only have one parent)", childNumber)
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("failed to add sub-issue link: %w", err)</span>
        }

        // Output confirmation - show repo info if cross-repo
        <span class="cov0" title="0">isCrossRepo := (parentOwner != childOwner || parentRepo != childRepo)
        if isCrossRepo </span><span class="cov0" title="0">{
                fmt.Printf(" Linked %s/%s#%d as sub-issue of %s/%s#%d\n",
                        childOwner, childRepo, childNumber,
                        parentOwner, parentRepo, parentNumber)
                fmt.Printf("  Parent: %s (%s/%s)\n", parentIssue.Title, parentOwner, parentRepo)
                fmt.Printf("  Child:  %s (%s/%s)\n", childIssue.Title, childOwner, childRepo)
        }</span> else<span class="cov0" title="0"> {
                fmt.Printf(" Linked issue #%d as sub-issue of #%d\n", childNumber, parentNumber)
                fmt.Printf("  Parent: %s\n", parentIssue.Title)
                fmt.Printf("  Child:  %s\n", childIssue.Title)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

type subCreateOptions struct {
        parent           string
        title            string
        body             string
        repo             string // Target repository for the new issue (owner/repo format)
        inheritLabels    bool
        inheritAssign    bool
        inheritMilestone bool
}

func newSubCreateCommand() *cobra.Command <span class="cov10" title="51">{
        opts := &amp;subCreateOptions{
                inheritLabels:    true,
                inheritAssign:    false,
                inheritMilestone: true,
        }

        cmd := &amp;cobra.Command{
                Use:   "create",
                Short: "Create a new issue as a sub-issue",
                Long: `Create a new issue and automatically link it as a sub-issue of a parent.

By default, the new issue is created in the same repository as the parent.
Use --repo to create the sub-issue in a different repository.

By default, the new issue inherits labels and milestone from the parent
(only when created in the same repository).

Examples:
  gh pmu sub create --parent 10 --title "Implement feature X"
  gh pmu sub create --parent #10 --title "Task" --body "Description"
  gh pmu sub create -p 10 -t "Task" --no-inherit-labels
  gh pmu sub create --parent owner/repo1#10 --repo owner/repo2 --title "Cross-repo task"`,
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        return runSubCreate(cmd, opts)
                }</span>,
        }

        <span class="cov10" title="51">cmd.Flags().StringVarP(&amp;opts.parent, "parent", "p", "", "Parent issue number or reference (required)")
        cmd.Flags().StringVarP(&amp;opts.title, "title", "t", "", "Issue title (required)")
        cmd.Flags().StringVarP(&amp;opts.body, "body", "b", "", "Issue body")
        cmd.Flags().StringVarP(&amp;opts.repo, "repo", "R", "", "Repository for the new issue (owner/repo format, defaults to parent's repo)")
        cmd.Flags().BoolVar(&amp;opts.inheritLabels, "inherit-labels", true, "Inherit labels from parent (same repo only)")
        cmd.Flags().BoolVar(&amp;opts.inheritAssign, "inherit-assignees", false, "Inherit assignees from parent (same repo only)")
        cmd.Flags().BoolVar(&amp;opts.inheritMilestone, "inherit-milestone", true, "Inherit milestone from parent (same repo only)")

        _ = cmd.MarkFlagRequired("parent")
        _ = cmd.MarkFlagRequired("title")

        return cmd</span>
}

func runSubCreate(cmd *cobra.Command, opts *subCreateOptions) error <span class="cov0" title="0">{
        // Load configuration
        cwd, err := os.Getwd()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get current directory: %w", err)
        }</span>

        <span class="cov0" title="0">cfg, err := config.LoadFromDirectory(cwd)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to load configuration: %w\nRun 'gh pmu init' to create a configuration file", err)
        }</span>

        <span class="cov0" title="0">if err := cfg.Validate(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid configuration: %w", err)
        }</span>

        // Parse parent issue reference
        <span class="cov0" title="0">parentOwner, parentRepo, parentNumber, err := parseIssueReference(opts.parent)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid parent issue: %w", err)
        }</span>

        // Default to configured repo if not specified
        <span class="cov0" title="0">if parentOwner == "" || parentRepo == "" </span><span class="cov0" title="0">{
                if len(cfg.Repositories) == 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("no repository specified and none configured")
                }</span>
                <span class="cov0" title="0">parts := strings.Split(cfg.Repositories[0], "/")
                if len(parts) != 2 </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid repository format in config: %s", cfg.Repositories[0])
                }</span>
                <span class="cov0" title="0">parentOwner = parts[0]
                parentRepo = parts[1]</span>
        }

        // Determine target repository for new issue
        <span class="cov0" title="0">targetOwner := parentOwner
        targetRepo := parentRepo
        isCrossRepo := false

        if opts.repo != "" </span><span class="cov0" title="0">{
                // Parse the --repo flag
                parts := strings.Split(opts.repo, "/")
                if len(parts) != 2 </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid repository format: %s (expected owner/repo)", opts.repo)
                }</span>
                <span class="cov0" title="0">targetOwner = parts[0]
                targetRepo = parts[1]
                isCrossRepo = (targetOwner != parentOwner || targetRepo != parentRepo)</span>
        }

        // Create API client
        <span class="cov0" title="0">client := api.NewClient()

        // Get parent issue to validate and optionally inherit from
        parentIssue, err := client.GetIssue(parentOwner, parentRepo, parentNumber)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get parent issue #%d: %w", parentNumber, err)
        }</span>

        // Build labels list (only inherit if same repo)
        <span class="cov0" title="0">var labels []string
        if !isCrossRepo &amp;&amp; opts.inheritLabels &amp;&amp; len(parentIssue.Labels) &gt; 0 </span><span class="cov0" title="0">{
                for _, l := range parentIssue.Labels </span><span class="cov0" title="0">{
                        labels = append(labels, l.Name)
                }</span>
        }

        // Create the new issue in target repository
        <span class="cov0" title="0">newIssue, err := client.CreateIssue(targetOwner, targetRepo, opts.title, opts.body, labels)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create issue in %s/%s: %w", targetOwner, targetRepo, err)
        }</span>

        // Link as sub-issue
        <span class="cov0" title="0">err = client.AddSubIssue(parentIssue.ID, newIssue.ID)
        if err != nil </span><span class="cov0" title="0">{
                // Issue was created but linking failed - inform user
                fmt.Fprintf(os.Stderr, "Warning: Issue created but failed to link as sub-issue: %v\n", err)
                fmt.Printf("Created issue #%d: %s\n", newIssue.Number, newIssue.Title)
                fmt.Printf("%s\n", newIssue.URL)
                return nil
        }</span>

        // Output confirmation
        <span class="cov0" title="0">if isCrossRepo </span><span class="cov0" title="0">{
                fmt.Printf(" Created cross-repo sub-issue %s/%s#%d under parent %s/%s#%d\n",
                        targetOwner, targetRepo, newIssue.Number,
                        parentOwner, parentRepo, parentNumber)
        }</span> else<span class="cov0" title="0"> {
                fmt.Printf(" Created sub-issue #%d under parent #%d\n", newIssue.Number, parentNumber)
        }</span>
        <span class="cov0" title="0">fmt.Printf("  Title:  %s\n", newIssue.Title)
        fmt.Printf("  Parent: %s\n", parentIssue.Title)
        if isCrossRepo </span><span class="cov0" title="0">{
                fmt.Printf("  Repo:   %s/%s\n", targetOwner, targetRepo)
        }</span>
        <span class="cov0" title="0">if len(labels) &gt; 0 </span><span class="cov0" title="0">{
                fmt.Printf("  Labels: %s (inherited)\n", strings.Join(labels, ", "))
        }</span>
        <span class="cov0" title="0">fmt.Printf(" %s\n", newIssue.URL)

        return nil</span>
}

type subListOptions struct {
        json bool
}

func newSubListCommand() *cobra.Command <span class="cov10" title="51">{
        opts := &amp;subListOptions{}

        cmd := &amp;cobra.Command{
                Use:   "list &lt;parent-issue&gt;",
                Short: "List sub-issues of a parent issue",
                Long: `List all sub-issues of a parent issue.

Displays the title, state, and assignee for each sub-issue,
along with a completion count.

Examples:
  gh pmu sub list 10        # List sub-issues of issue #10
  gh pmu sub list #10       # Same, with # prefix
  gh pmu sub list 10 --json # Output as JSON`,
                Args: cobra.ExactArgs(1),
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        return runSubList(cmd, args, opts)
                }</span>,
        }

        <span class="cov10" title="51">cmd.Flags().BoolVar(&amp;opts.json, "json", false, "Output in JSON format")

        return cmd</span>
}

func runSubList(cmd *cobra.Command, args []string, opts *subListOptions) error <span class="cov0" title="0">{
        // Load configuration
        cwd, err := os.Getwd()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get current directory: %w", err)
        }</span>

        <span class="cov0" title="0">cfg, err := config.LoadFromDirectory(cwd)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to load configuration: %w\nRun 'gh pmu init' to create a configuration file", err)
        }</span>

        <span class="cov0" title="0">if err := cfg.Validate(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid configuration: %w", err)
        }</span>

        // Parse parent issue reference
        <span class="cov0" title="0">parentOwner, parentRepo, parentNumber, err := parseIssueReference(args[0])
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid parent issue: %w", err)
        }</span>

        // Default to configured repo if not specified
        <span class="cov0" title="0">if parentOwner == "" || parentRepo == "" </span><span class="cov0" title="0">{
                if len(cfg.Repositories) == 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("no repository specified and none configured")
                }</span>
                <span class="cov0" title="0">parts := strings.Split(cfg.Repositories[0], "/")
                if len(parts) != 2 </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid repository format in config: %s", cfg.Repositories[0])
                }</span>
                <span class="cov0" title="0">parentOwner = parts[0]
                parentRepo = parts[1]</span>
        }

        // Create API client
        <span class="cov0" title="0">client := api.NewClient()

        // Get parent issue to validate it exists
        parentIssue, err := client.GetIssue(parentOwner, parentRepo, parentNumber)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get parent issue #%d: %w", parentNumber, err)
        }</span>

        // Get sub-issues
        <span class="cov0" title="0">subIssues, err := client.GetSubIssues(parentOwner, parentRepo, parentNumber)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get sub-issues: %w", err)
        }</span>

        // Output
        <span class="cov0" title="0">if opts.json </span><span class="cov0" title="0">{
                return outputSubListJSON(subIssues, parentIssue)
        }</span>

        <span class="cov0" title="0">return outputSubListTable(subIssues, parentIssue)</span>
}

// SubListJSONOutput represents the JSON output for sub list command
type SubListJSONOutput struct {
        Parent    SubListParent  `json:"parent"`
        SubIssues []SubListItem  `json:"subIssues"`
        Summary   SubListSummary `json:"summary"`
}

type SubListParent struct {
        Number int    `json:"number"`
        Title  string `json:"title"`
}

type SubListItem struct {
        Number     int    `json:"number"`
        Title      string `json:"title"`
        State      string `json:"state"`
        URL        string `json:"url"`
        Repository string `json:"repository"` // owner/repo format
}

type SubListSummary struct {
        Total  int `json:"total"`
        Open   int `json:"open"`
        Closed int `json:"closed"`
}

func outputSubListJSON(subIssues []api.SubIssue, parent *api.Issue) error <span class="cov0" title="0">{
        output := SubListJSONOutput{
                Parent: SubListParent{
                        Number: parent.Number,
                        Title:  parent.Title,
                },
                SubIssues: make([]SubListItem, 0, len(subIssues)),
                Summary: SubListSummary{
                        Total: len(subIssues),
                },
        }

        for _, sub := range subIssues </span><span class="cov0" title="0">{
                repoStr := ""
                if sub.Repository.Owner != "" &amp;&amp; sub.Repository.Name != "" </span><span class="cov0" title="0">{
                        repoStr = sub.Repository.Owner + "/" + sub.Repository.Name
                }</span>
                <span class="cov0" title="0">output.SubIssues = append(output.SubIssues, SubListItem{
                        Number:     sub.Number,
                        Title:      sub.Title,
                        State:      sub.State,
                        URL:        sub.URL,
                        Repository: repoStr,
                })

                if sub.State == "CLOSED" </span><span class="cov0" title="0">{
                        output.Summary.Closed++
                }</span> else<span class="cov0" title="0"> {
                        output.Summary.Open++
                }</span>
        }

        <span class="cov0" title="0">encoder := json.NewEncoder(os.Stdout)
        encoder.SetIndent("", "  ")
        return encoder.Encode(output)</span>
}

func outputSubListTable(subIssues []api.SubIssue, parent *api.Issue) error <span class="cov0" title="0">{
        fmt.Printf("Sub-issues of #%d: %s\n\n", parent.Number, parent.Title)

        if len(subIssues) == 0 </span><span class="cov0" title="0">{
                fmt.Println("No sub-issues found.")
                return nil
        }</span>

        // Check if any sub-issues are in different repos
        <span class="cov0" title="0">parentRepo := parent.Repository.Owner + "/" + parent.Repository.Name
        hasCrossRepo := false
        for _, sub := range subIssues </span><span class="cov0" title="0">{
                subRepo := sub.Repository.Owner + "/" + sub.Repository.Name
                if subRepo != parentRepo &amp;&amp; subRepo != "/" </span><span class="cov0" title="0">{
                        hasCrossRepo = true
                        break</span>
                }
        }

        <span class="cov0" title="0">closedCount := 0
        for _, sub := range subIssues </span><span class="cov0" title="0">{
                state := "[ ]"
                if sub.State == "CLOSED" </span><span class="cov0" title="0">{
                        state = "[x]"
                        closedCount++
                }</span>

                // Show repo info if there are cross-repo sub-issues
                <span class="cov0" title="0">if hasCrossRepo &amp;&amp; sub.Repository.Owner != "" &amp;&amp; sub.Repository.Name != "" </span><span class="cov0" title="0">{
                        subRepo := sub.Repository.Owner + "/" + sub.Repository.Name
                        fmt.Printf("  %s %s#%d - %s\n", state, subRepo, sub.Number, sub.Title)
                }</span> else<span class="cov0" title="0"> {
                        fmt.Printf("  %s #%d - %s\n", state, sub.Number, sub.Title)
                }</span>
        }

        <span class="cov0" title="0">fmt.Printf("\nProgress: %d/%d complete\n", closedCount, len(subIssues))

        return nil</span>
}

func newSubRemoveCommand() *cobra.Command <span class="cov10" title="51">{
        cmd := &amp;cobra.Command{
                Use:   "remove &lt;parent-issue&gt; &lt;child-issue&gt;",
                Short: "Remove a sub-issue link from a parent issue",
                Long: `Remove the sub-issue relationship between a parent and child issue.

This does NOT delete the child issue, only removes the parent-child link.
The child issue will become a standalone issue again.

Examples:
  gh pmu sub remove 10 15        # Unlink issue #15 from parent #10
  gh pmu sub remove #10 #15      # Same, with # prefix
  gh pmu sub remove owner/repo#10 owner/repo#15  # Full references`,
                Args: cobra.ExactArgs(2),
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        return runSubRemove(cmd, args)
                }</span>,
        }

        <span class="cov10" title="51">return cmd</span>
}

func runSubRemove(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
        // Load configuration
        cwd, err := os.Getwd()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get current directory: %w", err)
        }</span>

        <span class="cov0" title="0">cfg, err := config.LoadFromDirectory(cwd)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to load configuration: %w\nRun 'gh pmu init' to create a configuration file", err)
        }</span>

        <span class="cov0" title="0">if err := cfg.Validate(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid configuration: %w", err)
        }</span>

        // Parse parent issue reference
        <span class="cov0" title="0">parentOwner, parentRepo, parentNumber, err := parseIssueReference(args[0])
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid parent issue: %w", err)
        }</span>

        // Parse child issue reference
        <span class="cov0" title="0">childOwner, childRepo, childNumber, err := parseIssueReference(args[1])
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid child issue: %w", err)
        }</span>

        // Default to configured repo if not specified
        <span class="cov0" title="0">if parentOwner == "" || parentRepo == "" </span><span class="cov0" title="0">{
                if len(cfg.Repositories) == 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("no repository specified and none configured")
                }</span>
                <span class="cov0" title="0">parts := strings.Split(cfg.Repositories[0], "/")
                if len(parts) != 2 </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid repository format in config: %s", cfg.Repositories[0])
                }</span>
                <span class="cov0" title="0">parentOwner = parts[0]
                parentRepo = parts[1]</span>
        }

        <span class="cov0" title="0">if childOwner == "" || childRepo == "" </span><span class="cov0" title="0">{
                if len(cfg.Repositories) == 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("no repository specified and none configured")
                }</span>
                <span class="cov0" title="0">parts := strings.Split(cfg.Repositories[0], "/")
                if len(parts) != 2 </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid repository format in config: %s", cfg.Repositories[0])
                }</span>
                <span class="cov0" title="0">childOwner = parts[0]
                childRepo = parts[1]</span>
        }

        // Create API client
        <span class="cov0" title="0">client := api.NewClient()

        // Validate parent issue exists
        parentIssue, err := client.GetIssue(parentOwner, parentRepo, parentNumber)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get parent issue #%d: %w", parentNumber, err)
        }</span>

        // Validate child issue exists
        <span class="cov0" title="0">childIssue, err := client.GetIssue(childOwner, childRepo, childNumber)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get child issue #%d: %w", childNumber, err)
        }</span>

        // Remove sub-issue link
        <span class="cov0" title="0">err = client.RemoveSubIssue(parentIssue.ID, childIssue.ID)
        if err != nil </span><span class="cov0" title="0">{
                // Check if not linked
                errMsg := strings.ToLower(err.Error())
                if strings.Contains(errMsg, "not a sub-issue") || strings.Contains(errMsg, "not found") </span><span class="cov0" title="0">{
                        return fmt.Errorf("issue #%d is not a sub-issue of #%d", childNumber, parentNumber)
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("failed to remove sub-issue link: %w", err)</span>
        }

        // Output confirmation
        <span class="cov0" title="0">fmt.Printf(" Removed sub-issue link: #%d is no longer a sub-issue of #%d\n", childNumber, parentNumber)
        fmt.Printf("  Former parent: %s\n", parentIssue.Title)
        fmt.Printf("  Unlinked:      %s\n", childIssue.Title)

        return nil</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package cmd

import (
        "bufio"
        "encoding/json"
        "fmt"
        "os"
        "strings"
        "text/tabwriter"

        "github.com/scooter-indie/gh-pmu/internal/api"
        "github.com/scooter-indie/gh-pmu/internal/config"
        "github.com/spf13/cobra"
)

type triageOptions struct {
        dryRun      bool
        interactive bool
        json        bool
        list        bool
}

func newTriageCommand() *cobra.Command <span class="cov10" title="53">{
        opts := &amp;triageOptions{}

        cmd := &amp;cobra.Command{
                Use:   "triage [config-name]",
                Short: "Bulk process issues matching triage rules",
                Long: `Run triage rules to bulk update issues matching certain criteria.

Triage configurations are defined in .gh-pmu.yml under the 'triage' key.
Each triage config has a query to match issues and rules to apply.`,
                Aliases: []string{"tr"},
                Example: `  # List available triage configs
  gh pmu triage --list

  # Preview what a triage rule would do
  gh pmu triage tracked --dry-run

  # Run a triage rule
  gh pmu triage tracked

  # Run interactively (prompt for each issue)
  gh pmu triage tracked --interactive`,
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        return runTriage(cmd, args, opts)
                }</span>,
        }

        <span class="cov10" title="53">cmd.Flags().BoolVar(&amp;opts.dryRun, "dry-run", false, "Show what would be changed without making changes")
        cmd.Flags().BoolVarP(&amp;opts.interactive, "interactive", "i", false, "Prompt before processing each issue")
        cmd.Flags().BoolVar(&amp;opts.json, "json", false, "Output in JSON format")
        cmd.Flags().BoolVarP(&amp;opts.list, "list", "l", false, "List available triage configurations")

        return cmd</span>
}

func runTriage(cmd *cobra.Command, args []string, opts *triageOptions) error <span class="cov0" title="0">{
        // Load configuration
        cwd, err := os.Getwd()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get current directory: %w", err)
        }</span>

        <span class="cov0" title="0">cfg, err := config.LoadFromDirectory(cwd)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to load configuration: %w\nRun 'gh pmu init' to create a configuration file", err)
        }</span>

        <span class="cov0" title="0">if err := cfg.Validate(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid configuration: %w", err)
        }</span>

        // List mode
        <span class="cov0" title="0">if opts.list </span><span class="cov0" title="0">{
                return listTriageConfigs(cmd, cfg, opts.json)
        }</span>

        // Require config name
        <span class="cov0" title="0">if len(args) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("triage config name is required\nUse --list to see available configs")
        }</span>

        <span class="cov0" title="0">configName := args[0]
        triageCfg, ok := cfg.Triage[configName]
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("triage config %q not found\nUse --list to see available configs", configName)
        }</span>

        // Create API client
        <span class="cov0" title="0">client := api.NewClient()

        // Get project
        project, err := client.GetProject(cfg.Project.Owner, cfg.Project.Number)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get project: %w", err)
        }</span>

        // Search for issues matching the query
        <span class="cov0" title="0">matchingIssues, err := searchIssuesForTriage(client, cfg, triageCfg.Query)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to search issues: %w", err)
        }</span>

        <span class="cov0" title="0">if len(matchingIssues) == 0 </span><span class="cov0" title="0">{
                if opts.json </span><span class="cov0" title="0">{
                        return outputTriageJSON(cmd, nil, "no-matches", configName)
                }</span>
                <span class="cov0" title="0">cmd.Printf("No issues match the triage query for %q\n", configName)
                return nil</span>
        }

        // Dry run - just show what would be changed
        <span class="cov0" title="0">if opts.dryRun </span><span class="cov0" title="0">{
                if opts.json </span><span class="cov0" title="0">{
                        return outputTriageJSON(cmd, matchingIssues, "dry-run", configName)
                }</span>
                <span class="cov0" title="0">cmd.Printf("Would process %d issue(s) with triage config %q:\n\n", len(matchingIssues), configName)
                _ = outputTriageTable(cmd, matchingIssues)
                cmd.Println()
                describeTriageActions(cmd, cfg, &amp;triageCfg)
                return nil</span>
        }

        // Process issues
        <span class="cov0" title="0">var processed, skipped, failed int
        reader := bufio.NewReader(os.Stdin)

        for _, issue := range matchingIssues </span><span class="cov0" title="0">{
                // Interactive mode - prompt for each issue
                if opts.interactive </span><span class="cov0" title="0">{
                        cmd.Printf("\nProcess #%d: %s? [y/n/q] ", issue.Number, issue.Title)
                        response, _ := reader.ReadString('\n')
                        response = strings.TrimSpace(strings.ToLower(response))

                        if response == "q" </span><span class="cov0" title="0">{
                                cmd.Println("Aborted.")
                                break</span>
                        }
                        <span class="cov0" title="0">if response != "y" &amp;&amp; response != "yes" </span><span class="cov0" title="0">{
                                skipped++
                                continue</span>
                        }
                }

                // Apply triage rules
                <span class="cov0" title="0">err := applyTriageRules(client, cfg, project, &amp;issue, &amp;triageCfg)
                if err != nil </span><span class="cov0" title="0">{
                        cmd.PrintErrf("Failed to process #%d: %v\n", issue.Number, err)
                        failed++
                        continue</span>
                }

                <span class="cov0" title="0">processed++
                if !opts.interactive </span><span class="cov0" title="0">{
                        cmd.Printf("Processed #%d: %s\n", issue.Number, issue.Title)
                }</span>
        }

        // Summary
        <span class="cov0" title="0">if opts.json </span><span class="cov0" title="0">{
                return outputTriageJSON(cmd, matchingIssues, "completed", configName)
        }</span>

        <span class="cov0" title="0">cmd.Printf("\nTriage complete: %d processed", processed)
        if skipped &gt; 0 </span><span class="cov0" title="0">{
                cmd.Printf(", %d skipped", skipped)
        }</span>
        <span class="cov0" title="0">if failed &gt; 0 </span><span class="cov0" title="0">{
                cmd.Printf(", %d failed", failed)
        }</span>
        <span class="cov0" title="0">cmd.Println()

        return nil</span>
}

func listTriageConfigs(cmd *cobra.Command, cfg *config.Config, jsonOutput bool) error <span class="cov0" title="0">{
        if len(cfg.Triage) == 0 </span><span class="cov0" title="0">{
                if jsonOutput </span><span class="cov0" title="0">{
                        encoder := json.NewEncoder(os.Stdout)
                        encoder.SetIndent("", "  ")
                        return encoder.Encode(map[string]interface{}{"configs": []interface{}{}})
                }</span>
                <span class="cov0" title="0">cmd.Println("No triage configurations defined in .gh-pmu.yml")
                return nil</span>
        }

        <span class="cov0" title="0">if jsonOutput </span><span class="cov0" title="0">{
                type triageConfigJSON struct {
                        Name        string            `json:"name"`
                        Query       string            `json:"query"`
                        ApplyLabels []string          `json:"applyLabels,omitempty"`
                        ApplyFields map[string]string `json:"applyFields,omitempty"`
                }

                configs := make([]triageConfigJSON, 0, len(cfg.Triage))
                for name, tc := range cfg.Triage </span><span class="cov0" title="0">{
                        configs = append(configs, triageConfigJSON{
                                Name:        name,
                                Query:       tc.Query,
                                ApplyLabels: tc.Apply.Labels,
                                ApplyFields: tc.Apply.Fields,
                        })
                }</span>

                <span class="cov0" title="0">encoder := json.NewEncoder(os.Stdout)
                encoder.SetIndent("", "  ")
                return encoder.Encode(map[string]interface{}{"configs": configs})</span>
        }

        <span class="cov0" title="0">w := tabwriter.NewWriter(os.Stdout, 0, 0, 2, ' ', 0)
        fmt.Fprintln(w, "NAME\tQUERY\tACTIONS")

        for name, tc := range cfg.Triage </span><span class="cov0" title="0">{
                actions := describeActions(&amp;tc)
                query := tc.Query
                if len(query) &gt; 40 </span><span class="cov0" title="0">{
                        query = query[:37] + "..."
                }</span>
                <span class="cov0" title="0">fmt.Fprintf(w, "%s\t%s\t%s\n", name, query, actions)</span>
        }

        <span class="cov0" title="0">return w.Flush()</span>
}

func describeActions(tc *config.Triage) string <span class="cov0" title="0">{
        var actions []string

        if len(tc.Apply.Labels) &gt; 0 </span><span class="cov0" title="0">{
                actions = append(actions, fmt.Sprintf("labels: %s", strings.Join(tc.Apply.Labels, ", ")))
        }</span>

        <span class="cov0" title="0">for field, value := range tc.Apply.Fields </span><span class="cov0" title="0">{
                actions = append(actions, fmt.Sprintf("%s: %s", field, value))
        }</span>

        <span class="cov0" title="0">if len(actions) == 0 </span><span class="cov0" title="0">{
                if tc.Interactive.Status || tc.Interactive.Estimate </span><span class="cov0" title="0">{
                        return "interactive only"
                }</span>
                <span class="cov0" title="0">return "none"</span>
        }

        <span class="cov0" title="0">return strings.Join(actions, "; ")</span>
}

func describeTriageActions(cmd *cobra.Command, cfg *config.Config, tc *config.Triage) <span class="cov0" title="0">{
        cmd.Println("Actions to apply:")

        if len(tc.Apply.Labels) &gt; 0 </span><span class="cov0" title="0">{
                cmd.Printf("   Add labels: %s\n", strings.Join(tc.Apply.Labels, ", "))
        }</span>

        <span class="cov0" title="0">for field, value := range tc.Apply.Fields </span><span class="cov0" title="0">{
                resolved := cfg.ResolveFieldValue(field, value)
                cmd.Printf("   Set %s: %s\n", field, resolved)
        }</span>

        <span class="cov0" title="0">if tc.Interactive.Status </span><span class="cov0" title="0">{
                cmd.Println("   Prompt for status (interactive)")
        }</span>
        <span class="cov0" title="0">if tc.Interactive.Estimate </span><span class="cov0" title="0">{
                cmd.Println("   Prompt for estimate (interactive)")
        }</span>
}

func searchIssuesForTriage(client *api.Client, cfg *config.Config, query string) ([]api.Issue, error) <span class="cov0" title="0">{
        // Parse the query to determine what to search for
        // For now, we search issues in configured repositories and filter locally
        // A more sophisticated implementation would use GitHub's search API

        var allIssues []api.Issue

        for _, repoFullName := range cfg.Repositories </span><span class="cov0" title="0">{
                parts := strings.SplitN(repoFullName, "/", 2)
                if len(parts) != 2 </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">owner, repo := parts[0], parts[1]

                // Determine state from query
                state := "open"
                if strings.Contains(query, "is:closed") </span><span class="cov0" title="0">{
                        state = "closed"
                }</span> else<span class="cov0" title="0"> if strings.Contains(query, "is:all") </span><span class="cov0" title="0">{
                        state = "all"
                }</span>

                <span class="cov0" title="0">issues, err := client.GetRepositoryIssues(owner, repo, state)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Filter based on query components
                <span class="cov0" title="0">for _, issue := range issues </span><span class="cov0" title="0">{
                        if matchesTriageQuery(issue, query) </span><span class="cov0" title="0">{
                                allIssues = append(allIssues, issue)
                        }</span>
                }
        }

        <span class="cov0" title="0">return allIssues, nil</span>
}

func matchesTriageQuery(issue api.Issue, query string) bool <span class="cov0" title="0">{
        // Basic query matching - supports common GitHub search qualifiers
        // This is a simplified version; full implementation would parse the query properly

        // Check for label requirements
        if strings.Contains(query, "-label:") </span><span class="cov0" title="0">{
                // Extract label name after -label:
                parts := strings.Split(query, "-label:")
                for _, part := range parts[1:] </span><span class="cov0" title="0">{
                        labelName := strings.Fields(part)[0]
                        // Check if issue has this label
                        for _, label := range issue.Labels </span><span class="cov0" title="0">{
                                if label.Name == labelName </span><span class="cov0" title="0">{
                                        return false // Has excluded label
                                }</span>
                        }
                }
        }

        <span class="cov0" title="0">if strings.Contains(query, "label:") &amp;&amp; !strings.Contains(query, "-label:") </span><span class="cov0" title="0">{
                // Must have specified label
                parts := strings.Split(query, "label:")
                for _, part := range parts[1:] </span><span class="cov0" title="0">{
                        if strings.HasPrefix(part, "-") </span><span class="cov0" title="0">{
                                continue</span> // Skip negations
                        }
                        <span class="cov0" title="0">labelName := strings.Fields(part)[0]
                        found := false
                        for _, label := range issue.Labels </span><span class="cov0" title="0">{
                                if label.Name == labelName </span><span class="cov0" title="0">{
                                        found = true
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if !found </span><span class="cov0" title="0">{
                                return false
                        }</span>
                }
        }

        // Check state
        <span class="cov0" title="0">if strings.Contains(query, "is:open") &amp;&amp; issue.State != "OPEN" </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">if strings.Contains(query, "is:closed") &amp;&amp; issue.State != "CLOSED" </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">return true</span>
}

func applyTriageRules(client *api.Client, cfg *config.Config, project *api.Project, issue *api.Issue, tc *config.Triage) error <span class="cov0" title="0">{
        // First, ensure issue is in the project
        itemID, err := ensureIssueInProject(client, project.ID, issue.ID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to add issue to project: %w", err)
        }</span>

        // Apply labels
        <span class="cov0" title="0">if len(tc.Apply.Labels) &gt; 0 </span><span class="cov0" title="0">{
                for _, label := range tc.Apply.Labels </span><span class="cov0" title="0">{
                        if err := client.AddLabelToIssue(issue.ID, label); err != nil </span><span class="cov0" title="0">{
                                // Log but don't fail - label might already exist
                                continue</span>
                        }
                }
        }

        // Apply fields
        <span class="cov0" title="0">for field, value := range tc.Apply.Fields </span><span class="cov0" title="0">{
                fieldName := cfg.GetFieldName(field)
                resolvedValue := cfg.ResolveFieldValue(field, value)

                if err := client.SetProjectItemField(project.ID, itemID, fieldName, resolvedValue); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to set %s: %w", field, err)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func ensureIssueInProject(client *api.Client, projectID, issueID string) (string, error) <span class="cov0" title="0">{
        // Try to add - if already exists, this should return the existing item ID
        itemID, err := client.AddIssueToProject(projectID, issueID)
        if err != nil </span><span class="cov0" title="0">{
                // If error mentions already exists, try to find existing item
                if strings.Contains(err.Error(), "already") </span><span class="cov0" title="0">{
                        // For now, just return the error - we'd need a query to find existing item
                        return "", err
                }</span>
                <span class="cov0" title="0">return "", err</span>
        }
        <span class="cov0" title="0">return itemID, nil</span>
}

func outputTriageTable(cmd *cobra.Command, issues []api.Issue) error <span class="cov0" title="0">{
        w := tabwriter.NewWriter(os.Stdout, 0, 0, 2, ' ', 0)
        fmt.Fprintln(w, "NUMBER\tTITLE\tSTATE\tLABELS")

        for _, issue := range issues </span><span class="cov0" title="0">{
                title := issue.Title
                if len(title) &gt; 45 </span><span class="cov0" title="0">{
                        title = title[:42] + "..."
                }</span>

                <span class="cov0" title="0">var labels []string
                for _, l := range issue.Labels </span><span class="cov0" title="0">{
                        labels = append(labels, l.Name)
                }</span>
                <span class="cov0" title="0">labelStr := strings.Join(labels, ", ")
                if labelStr == "" </span><span class="cov0" title="0">{
                        labelStr = "-"
                }</span>

                <span class="cov0" title="0">fmt.Fprintf(w, "#%d\t%s\t%s\t%s\n", issue.Number, title, issue.State, labelStr)</span>
        }

        <span class="cov0" title="0">return w.Flush()</span>
}

type triageJSONOutput struct {
        Status     string            `json:"status"`
        ConfigName string            `json:"configName"`
        Count      int               `json:"count"`
        Issues     []triageJSONIssue `json:"issues"`
}

type triageJSONIssue struct {
        Number int      `json:"number"`
        Title  string   `json:"title"`
        State  string   `json:"state"`
        URL    string   `json:"url"`
        Labels []string `json:"labels"`
}

func outputTriageJSON(cmd *cobra.Command, issues []api.Issue, status, configName string) error <span class="cov0" title="0">{
        output := triageJSONOutput{
                Status:     status,
                ConfigName: configName,
                Count:      len(issues),
                Issues:     make([]triageJSONIssue, 0, len(issues)),
        }

        for _, issue := range issues </span><span class="cov0" title="0">{
                labels := make([]string, 0, len(issue.Labels))
                for _, l := range issue.Labels </span><span class="cov0" title="0">{
                        labels = append(labels, l.Name)
                }</span>

                <span class="cov0" title="0">output.Issues = append(output.Issues, triageJSONIssue{
                        Number: issue.Number,
                        Title:  issue.Title,
                        State:  issue.State,
                        URL:    issue.URL,
                        Labels: labels,
                })</span>
        }

        <span class="cov0" title="0">encoder := json.NewEncoder(os.Stdout)
        encoder.SetIndent("", "  ")
        return encoder.Encode(output)</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package cmd

import (
        "encoding/json"
        "fmt"
        "os"
        "strconv"
        "strings"

        "github.com/scooter-indie/gh-pmu/internal/api"
        "github.com/scooter-indie/gh-pmu/internal/config"
        "github.com/spf13/cobra"
)

type viewOptions struct {
        json bool
}

func newViewCommand() *cobra.Command <span class="cov10" title="51">{
        opts := &amp;viewOptions{}

        cmd := &amp;cobra.Command{
                Use:   "view &lt;issue-number&gt;",
                Short: "View an issue with project metadata",
                Long: `View an issue with all its project field values.

Displays issue details including title, body, state, labels, assignees,
and all project-specific fields like Status and Priority.

Also shows sub-issues if any exist, and parent issue if this is a sub-issue.`,
                Args: cobra.ExactArgs(1),
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        return runView(cmd, args, opts)
                }</span>,
        }

        <span class="cov10" title="51">cmd.Flags().BoolVar(&amp;opts.json, "json", false, "Output in JSON format")

        return cmd</span>
}

func runView(cmd *cobra.Command, args []string, opts *viewOptions) error <span class="cov0" title="0">{
        // Load configuration
        cwd, err := os.Getwd()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get current directory: %w", err)
        }</span>

        <span class="cov0" title="0">cfg, err := config.LoadFromDirectory(cwd)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to load configuration: %w\nRun 'gh pmu init' to create a configuration file", err)
        }</span>

        <span class="cov0" title="0">if err := cfg.Validate(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid configuration: %w", err)
        }</span>

        // Parse issue reference
        <span class="cov0" title="0">owner, repo, number, err := parseIssueReference(args[0])
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // If owner/repo not specified, use first repo from config
        <span class="cov0" title="0">if owner == "" || repo == "" </span><span class="cov0" title="0">{
                if len(cfg.Repositories) == 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("no repository specified and none configured")
                }</span>
                <span class="cov0" title="0">parts := strings.Split(cfg.Repositories[0], "/")
                if len(parts) != 2 </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid repository format in config: %s", cfg.Repositories[0])
                }</span>
                <span class="cov0" title="0">owner = parts[0]
                repo = parts[1]</span>
        }

        // Create API client
        <span class="cov0" title="0">client := api.NewClient()

        // Fetch issue
        issue, err := client.GetIssue(owner, repo, number)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get issue: %w", err)
        }</span>

        // Fetch project items to get field values for this issue
        <span class="cov0" title="0">project, err := client.GetProject(cfg.Project.Owner, cfg.Project.Number)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get project: %w", err)
        }</span>

        <span class="cov0" title="0">items, err := client.GetProjectItems(project.ID, nil)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get project items: %w", err)
        }</span>

        // Find this issue in project items to get field values
        <span class="cov0" title="0">var fieldValues []api.FieldValue
        for _, item := range items </span><span class="cov0" title="0">{
                if item.Issue != nil &amp;&amp; item.Issue.Number == number </span><span class="cov0" title="0">{
                        fieldValues = item.FieldValues
                        break</span>
                }
        }

        // Fetch sub-issues (if any)
        <span class="cov0" title="0">subIssues, err := client.GetSubIssues(owner, repo, number)
        if err != nil </span><span class="cov0" title="0">{
                // Non-fatal - issue might not have sub-issues or API might not support it
                subIssues = nil
        }</span>

        // Fetch parent issue (if this is a sub-issue)
        <span class="cov0" title="0">parentIssue, err := client.GetParentIssue(owner, repo, number)
        if err != nil </span><span class="cov0" title="0">{
                // Non-fatal - issue might not be a sub-issue
                parentIssue = nil
        }</span>

        // Output
        <span class="cov0" title="0">if opts.json </span><span class="cov0" title="0">{
                return outputViewJSON(cmd, issue, fieldValues, subIssues, parentIssue)
        }</span>

        <span class="cov0" title="0">return outputViewTable(cmd, issue, fieldValues, subIssues, parentIssue)</span>
}

// ViewJSONOutput represents the JSON output for view command
type ViewJSONOutput struct {
        Number      int               `json:"number"`
        Title       string            `json:"title"`
        State       string            `json:"state"`
        Body        string            `json:"body"`
        URL         string            `json:"url"`
        Author      string            `json:"author"`
        Assignees   []string          `json:"assignees"`
        Labels      []string          `json:"labels"`
        Milestone   string            `json:"milestone,omitempty"`
        FieldValues map[string]string `json:"fieldValues"`
        SubIssues   []SubIssueJSON    `json:"subIssues,omitempty"`
        SubProgress *SubProgressJSON  `json:"subProgress,omitempty"`
        ParentIssue *ParentIssueJSON  `json:"parentIssue,omitempty"`
}

// SubProgressJSON represents sub-issue progress in JSON output
type SubProgressJSON struct {
        Total      int `json:"total"`
        Completed  int `json:"completed"`
        Percentage int `json:"percentage"`
}

// SubIssueJSON represents a sub-issue in JSON output
type SubIssueJSON struct {
        Number int    `json:"number"`
        Title  string `json:"title"`
        State  string `json:"state"`
        URL    string `json:"url"`
}

// ParentIssueJSON represents the parent issue in JSON output
type ParentIssueJSON struct {
        Number int    `json:"number"`
        Title  string `json:"title"`
        URL    string `json:"url"`
}

func outputViewJSON(cmd *cobra.Command, issue *api.Issue, fieldValues []api.FieldValue, subIssues []api.SubIssue, parentIssue *api.Issue) error <span class="cov0" title="0">{
        output := ViewJSONOutput{
                Number:      issue.Number,
                Title:       issue.Title,
                State:       issue.State,
                Body:        issue.Body,
                URL:         issue.URL,
                Author:      issue.Author.Login,
                Assignees:   make([]string, 0),
                Labels:      make([]string, 0),
                FieldValues: make(map[string]string),
        }

        for _, a := range issue.Assignees </span><span class="cov0" title="0">{
                output.Assignees = append(output.Assignees, a.Login)
        }</span>

        <span class="cov0" title="0">for _, l := range issue.Labels </span><span class="cov0" title="0">{
                output.Labels = append(output.Labels, l.Name)
        }</span>

        <span class="cov0" title="0">if issue.Milestone != nil </span><span class="cov0" title="0">{
                output.Milestone = issue.Milestone.Title
        }</span>

        <span class="cov0" title="0">for _, fv := range fieldValues </span><span class="cov0" title="0">{
                output.FieldValues[fv.Field] = fv.Value
        }</span>

        <span class="cov0" title="0">if len(subIssues) &gt; 0 </span><span class="cov0" title="0">{
                output.SubIssues = make([]SubIssueJSON, 0, len(subIssues))
                closedCount := 0
                for _, sub := range subIssues </span><span class="cov0" title="0">{
                        output.SubIssues = append(output.SubIssues, SubIssueJSON{
                                Number: sub.Number,
                                Title:  sub.Title,
                                State:  sub.State,
                                URL:    sub.URL,
                        })
                        if sub.State == "CLOSED" </span><span class="cov0" title="0">{
                                closedCount++
                        }</span>
                }

                // Add progress info
                <span class="cov0" title="0">total := len(subIssues)
                percentage := 0
                if total &gt; 0 </span><span class="cov0" title="0">{
                        percentage = (closedCount * 100) / total
                }</span>
                <span class="cov0" title="0">output.SubProgress = &amp;SubProgressJSON{
                        Total:      total,
                        Completed:  closedCount,
                        Percentage: percentage,
                }</span>
        }

        <span class="cov0" title="0">if parentIssue != nil </span><span class="cov0" title="0">{
                output.ParentIssue = &amp;ParentIssueJSON{
                        Number: parentIssue.Number,
                        Title:  parentIssue.Title,
                        URL:    parentIssue.URL,
                }
        }</span>

        <span class="cov0" title="0">encoder := json.NewEncoder(os.Stdout)
        encoder.SetIndent("", "  ")
        return encoder.Encode(output)</span>
}

func outputViewTable(cmd *cobra.Command, issue *api.Issue, fieldValues []api.FieldValue, subIssues []api.SubIssue, parentIssue *api.Issue) error <span class="cov0" title="0">{
        // Title and state
        fmt.Printf("%s #%d\n", issue.Title, issue.Number)
        fmt.Printf("State: %s\n", issue.State)
        fmt.Printf("URL: %s\n", issue.URL)
        fmt.Println()

        // Author
        fmt.Printf("Author: @%s\n", issue.Author.Login)

        // Assignees
        if len(issue.Assignees) &gt; 0 </span><span class="cov0" title="0">{
                var assignees []string
                for _, a := range issue.Assignees </span><span class="cov0" title="0">{
                        assignees = append(assignees, "@"+a.Login)
                }</span>
                <span class="cov0" title="0">fmt.Printf("Assignees: %s\n", strings.Join(assignees, ", "))</span>
        }

        // Labels
        <span class="cov0" title="0">if len(issue.Labels) &gt; 0 </span><span class="cov0" title="0">{
                var labels []string
                for _, l := range issue.Labels </span><span class="cov0" title="0">{
                        labels = append(labels, l.Name)
                }</span>
                <span class="cov0" title="0">fmt.Printf("Labels: %s\n", strings.Join(labels, ", "))</span>
        }

        // Milestone
        <span class="cov0" title="0">if issue.Milestone != nil </span><span class="cov0" title="0">{
                fmt.Printf("Milestone: %s\n", issue.Milestone.Title)
        }</span>

        // Project field values
        <span class="cov0" title="0">if len(fieldValues) &gt; 0 </span><span class="cov0" title="0">{
                fmt.Println()
                fmt.Println("Project Fields:")
                for _, fv := range fieldValues </span><span class="cov0" title="0">{
                        fmt.Printf("  %s: %s\n", fv.Field, fv.Value)
                }</span>
        }

        // Parent issue
        <span class="cov0" title="0">if parentIssue != nil </span><span class="cov0" title="0">{
                fmt.Println()
                fmt.Printf("Parent Issue: #%d - %s\n", parentIssue.Number, parentIssue.Title)
        }</span>

        // Sub-issues with progress bar
        <span class="cov0" title="0">if len(subIssues) &gt; 0 </span><span class="cov0" title="0">{
                fmt.Println()
                fmt.Println("Sub-Issues:")
                closedCount := 0
                for _, sub := range subIssues </span><span class="cov0" title="0">{
                        state := "[ ]"
                        if sub.State == "CLOSED" </span><span class="cov0" title="0">{
                                state = "[x]"
                                closedCount++
                        }</span>
                        // Show repo info if cross-repo
                        <span class="cov0" title="0">if sub.Repository.Owner != "" &amp;&amp; sub.Repository.Name != "" </span><span class="cov0" title="0">{
                                parentRepo := issue.Repository.Owner + "/" + issue.Repository.Name
                                subRepo := sub.Repository.Owner + "/" + sub.Repository.Name
                                if subRepo != parentRepo </span><span class="cov0" title="0">{
                                        fmt.Printf("  %s %s#%d - %s\n", state, subRepo, sub.Number, sub.Title)
                                        continue</span>
                                }
                        }
                        <span class="cov0" title="0">fmt.Printf("  %s #%d - %s\n", state, sub.Number, sub.Title)</span>
                }

                // Progress bar and percentage
                <span class="cov0" title="0">total := len(subIssues)
                percentage := 0
                if total &gt; 0 </span><span class="cov0" title="0">{
                        percentage = (closedCount * 100) / total
                }</span>
                <span class="cov0" title="0">progressBar := renderProgressBar(closedCount, total, 20)
                fmt.Printf("\n%s %d of %d sub-issues complete (%d%%)\n", progressBar, closedCount, total, percentage)</span>
        }

        // Body
        <span class="cov0" title="0">if issue.Body != "" </span><span class="cov0" title="0">{
                fmt.Println()
                fmt.Println("---")
                fmt.Println(issue.Body)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// renderProgressBar creates a visual progress bar
// Example: [] for 40% complete
func renderProgressBar(completed, total, width int) string <span class="cov5" title="7">{
        if total == 0 </span><span class="cov1" title="1">{
                return "[" + strings.Repeat("", width) + "]"
        }</span>

        <span class="cov5" title="6">filled := (completed * width) / total
        if filled &gt; width </span><span class="cov1" title="1">{
                filled = width
        }</span>

        <span class="cov5" title="6">empty := width - filled
        return "[" + strings.Repeat("", filled) + strings.Repeat("", empty) + "]"</span>
}

// parseIssueNumber parses a string into an issue number
// Accepts formats: "123" or "#123"
func parseIssueNumber(s string) (int, error) <span class="cov6" title="9">{
        // Strip leading # if present
        s = strings.TrimPrefix(s, "#")

        num, err := strconv.Atoi(s)
        if err != nil </span><span class="cov2" title="2">{
                return 0, fmt.Errorf("invalid issue number: %s", s)
        }</span>

        <span class="cov5" title="7">if num &lt;= 0 </span><span class="cov2" title="2">{
                return 0, fmt.Errorf("issue number must be positive: %d", num)
        }</span>

        <span class="cov4" title="5">return num, nil</span>
}

// parseIssueReference parses an issue reference string
// Accepts formats: "123", "#123", or "owner/repo#123"
// Returns owner, repo, number (owner/repo may be empty if not specified)
func parseIssueReference(s string) (owner, repo string, number int, err error) <span class="cov4" title="4">{
        // Check for owner/repo#number format
        if idx := strings.Index(s, "#"); idx &gt; 0 </span><span class="cov1" title="1">{
                // Has # with something before it - could be owner/repo#number
                repoRef := s[:idx]
                numStr := s[idx+1:]

                if slashIdx := strings.Index(repoRef, "/"); slashIdx &gt; 0 </span><span class="cov1" title="1">{
                        owner = repoRef[:slashIdx]
                        repo = repoRef[slashIdx+1:]

                        number, err = parseIssueNumber(numStr)
                        if err != nil </span><span class="cov0" title="0">{
                                return "", "", 0, err
                        }</span>
                        <span class="cov1" title="1">return owner, repo, number, nil</span>
                }
        }

        // Try parsing as simple number or #number
        <span class="cov3" title="3">number, err = parseIssueNumber(s)
        if err != nil </span><span class="cov1" title="1">{
                return "", "", 0, fmt.Errorf("invalid issue reference: %s", s)
        }</span>

        <span class="cov2" title="2">return "", "", number, nil</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package api

import (
        "github.com/cli/go-gh/v2/pkg/api"
)

// FeatureSubIssues is the GitHub API preview header for sub-issues
const FeatureSubIssues = "sub_issues"

// FeatureIssueTypes is the GitHub API preview header for issue types
const FeatureIssueTypes = "issue_types"

// Client wraps the GitHub GraphQL API client with project management features
type Client struct {
        gql  *api.GraphQLClient
        opts ClientOptions
}

// ClientOptions configures the API client
type ClientOptions struct {
        // Host is the GitHub hostname (default: github.com)
        Host string

        // EnableSubIssues enables the sub_issues feature preview
        EnableSubIssues bool

        // EnableIssueTypes enables the issue_types feature preview
        EnableIssueTypes bool
}

// NewClient creates a new API client with default options
func NewClient() *Client <span class="cov4" title="2">{
        return NewClientWithOptions(ClientOptions{
                EnableSubIssues:  true,
                EnableIssueTypes: true,
        })
}</span>

// NewClientWithOptions creates a new API client with custom options
func NewClientWithOptions(opts ClientOptions) *Client <span class="cov7" title="3">{
        // Build headers with feature previews
        headers := make(map[string]string)

        // Add GraphQL feature preview headers
        // These enable beta features in the GitHub API
        featureHeaders := []string{}
        if opts.EnableSubIssues </span><span class="cov4" title="2">{
                featureHeaders = append(featureHeaders, FeatureSubIssues)
        }</span>
        <span class="cov7" title="3">if opts.EnableIssueTypes </span><span class="cov4" title="2">{
                featureHeaders = append(featureHeaders, FeatureIssueTypes)
        }</span>

        <span class="cov7" title="3">if len(featureHeaders) &gt; 0 </span><span class="cov4" title="2">{
                // GitHub uses X-Github-Next for feature previews
                headers["X-Github-Next"] = joinFeatures(featureHeaders)
        }</span>

        // Create GraphQL client options
        <span class="cov7" title="3">apiOpts := api.ClientOptions{
                Headers: headers,
        }

        if opts.Host != "" </span><span class="cov1" title="1">{
                apiOpts.Host = opts.Host
        }</span>

        // Create the GraphQL client
        <span class="cov7" title="3">gql, err := api.NewGraphQLClient(apiOpts)
        if err != nil </span><span class="cov7" title="3">{
                // If we can't create a client (e.g., not authenticated),
                // return a client with nil gql - methods will return errors
                return &amp;Client{opts: opts}
        }</span>

        <span class="cov0" title="0">return &amp;Client{
                gql:  gql,
                opts: opts,
        }</span>
}

// joinFeatures joins feature names with commas
func joinFeatures(features []string) string <span class="cov10" title="5">{
        if len(features) == 0 </span><span class="cov1" title="1">{
                return ""
        }</span>
        <span class="cov8" title="4">result := features[0]
        for i := 1; i &lt; len(features); i++ </span><span class="cov7" title="3">{
                result += "," + features[i]
        }</span>
        <span class="cov8" title="4">return result</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package api

import (
        "errors"
        "fmt"
        "strings"
)

// Common errors
var (
        ErrNotAuthenticated = errors.New("not authenticated - run 'gh auth login' first")
        ErrNotFound         = errors.New("resource not found")
        ErrRateLimited      = errors.New("API rate limit exceeded")
)

// APIError wraps GitHub API errors with additional context
type APIError struct {
        Operation string
        Resource  string
        Err       error
}

func (e *APIError) Error() string <span class="cov1" title="1">{
        return fmt.Sprintf("%s %s: %v", e.Operation, e.Resource, e.Err)
}</span>

func (e *APIError) Unwrap() error <span class="cov1" title="1">{
        return e.Err
}</span>

// IsNotFound checks if an error indicates a resource was not found
func IsNotFound(err error) bool <span class="cov10" title="5">{
        if errors.Is(err, ErrNotFound) </span><span class="cov1" title="1">{
                return true
        }</span>
        <span class="cov8" title="4">if err == nil </span><span class="cov1" title="1">{
                return false
        }</span>
        // Check for GraphQL "not found" patterns
        <span class="cov7" title="3">msg := err.Error()
        return strings.Contains(msg, "Could not resolve") ||
                strings.Contains(msg, "NOT_FOUND")</span>
}

// IsRateLimited checks if an error indicates rate limiting
func IsRateLimited(err error) bool <span class="cov8" title="4">{
        if errors.Is(err, ErrRateLimited) </span><span class="cov1" title="1">{
                return true
        }</span>
        <span class="cov7" title="3">if err == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov7" title="3">msg := err.Error()
        return strings.Contains(msg, "rate limit") ||
                strings.Contains(msg, "RATE_LIMITED")</span>
}

// IsAuthError checks if an error indicates authentication issues
func IsAuthError(err error) bool <span class="cov4" title="2">{
        if errors.Is(err, ErrNotAuthenticated) </span><span class="cov1" title="1">{
                return true
        }</span>
        <span class="cov1" title="1">if err == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov1" title="1">msg := err.Error()
        return strings.Contains(msg, "401") ||
                strings.Contains(msg, "authentication") ||
                strings.Contains(msg, "not authenticated")</span>
}

// WrapError wraps an API error with operation context
func WrapError(operation, resource string, err error) error <span class="cov7" title="3">{
        if err == nil </span><span class="cov1" title="1">{
                return nil
        }</span>

        // Check for specific error types and wrap accordingly
        <span class="cov4" title="2">if IsRateLimited(err) </span><span class="cov1" title="1">{
                return &amp;APIError{
                        Operation: operation,
                        Resource:  resource,
                        Err:       ErrRateLimited,
                }
        }</span>

        <span class="cov1" title="1">if IsNotFound(err) </span><span class="cov1" title="1">{
                return &amp;APIError{
                        Operation: operation,
                        Resource:  resource,
                        Err:       ErrNotFound,
                }
        }</span>

        <span class="cov0" title="0">return &amp;APIError{
                Operation: operation,
                Resource:  resource,
                Err:       err,
        }</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package api

import (
        "fmt"

        graphql "github.com/cli/shurcooL-graphql"
)

// CreateIssue creates a new issue in a repository
func (c *Client) CreateIssue(owner, repo, title, body string, labels []string) (*Issue, error) <span class="cov0" title="0">{
        if c.gql == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("GraphQL client not initialized - are you authenticated with gh?")
        }</span>

        // First, get the repository ID
        <span class="cov0" title="0">repoID, err := c.getRepositoryID(owner, repo)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Get label IDs if labels are provided
        <span class="cov0" title="0">var labelIDs []graphql.ID
        if len(labels) &gt; 0 </span><span class="cov0" title="0">{
                for _, labelName := range labels </span><span class="cov0" title="0">{
                        labelID, err := c.getLabelID(owner, repo, labelName)
                        if err != nil </span><span class="cov0" title="0">{
                                // Skip labels that don't exist
                                continue</span>
                        }
                        <span class="cov0" title="0">labelIDs = append(labelIDs, graphql.ID(labelID))</span>
                }
        }

        <span class="cov0" title="0">var mutation struct {
                CreateIssue struct {
                        Issue struct {
                                ID     string
                                Number int
                                Title  string
                                Body   string
                                State  string
                                URL    string `graphql:"url"`
                        }
                } `graphql:"createIssue(input: $input)"`
        }

        input := CreateIssueInput{
                RepositoryID: graphql.ID(repoID),
                Title:        graphql.String(title),
        }
        if body != "" </span><span class="cov0" title="0">{
                input.Body = graphql.String(body)
        }</span>
        <span class="cov0" title="0">if len(labelIDs) &gt; 0 </span><span class="cov0" title="0">{
                input.LabelIDs = &amp;labelIDs
        }</span>

        <span class="cov0" title="0">variables := map[string]interface{}{
                "input": input,
        }

        err = c.gql.Mutate("CreateIssue", &amp;mutation, variables)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create issue: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;Issue{
                ID:     mutation.CreateIssue.Issue.ID,
                Number: mutation.CreateIssue.Issue.Number,
                Title:  mutation.CreateIssue.Issue.Title,
                Body:   mutation.CreateIssue.Issue.Body,
                State:  mutation.CreateIssue.Issue.State,
                URL:    mutation.CreateIssue.Issue.URL,
                Repository: Repository{
                        Owner: owner,
                        Name:  repo,
                },
        }, nil</span>
}

// CreateIssueInput represents the input for creating an issue
type CreateIssueInput struct {
        RepositoryID graphql.ID     `json:"repositoryId"`
        Title        graphql.String `json:"title"`
        Body         graphql.String `json:"body,omitempty"`
        LabelIDs     *[]graphql.ID  `json:"labelIds,omitempty"`
        AssigneeIDs  *[]graphql.ID  `json:"assigneeIds,omitempty"`
        MilestoneID  *graphql.ID    `json:"milestoneId,omitempty"`
}

// AddIssueToProject adds an issue to a GitHub Project V2
func (c *Client) AddIssueToProject(projectID, issueID string) (string, error) <span class="cov0" title="0">{
        if c.gql == nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("GraphQL client not initialized - are you authenticated with gh?")
        }</span>

        <span class="cov0" title="0">var mutation struct {
                AddProjectV2ItemById struct {
                        Item struct {
                                ID string
                        }
                } `graphql:"addProjectV2ItemById(input: $input)"`
        }

        input := AddProjectV2ItemByIdInput{
                ProjectID: graphql.ID(projectID),
                ContentID: graphql.ID(issueID),
        }

        variables := map[string]interface{}{
                "input": input,
        }

        err := c.gql.Mutate("AddProjectV2ItemById", &amp;mutation, variables)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to add issue to project: %w", err)
        }</span>

        <span class="cov0" title="0">return mutation.AddProjectV2ItemById.Item.ID, nil</span>
}

// AddProjectV2ItemByIdInput represents the input for adding an item to a project
type AddProjectV2ItemByIdInput struct {
        ProjectID graphql.ID `json:"projectId"`
        ContentID graphql.ID `json:"contentId"`
}

// SetProjectItemField sets a field value on a project item
func (c *Client) SetProjectItemField(projectID, itemID, fieldName, value string) error <span class="cov0" title="0">{
        if c.gql == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("GraphQL client not initialized - are you authenticated with gh?")
        }</span>

        // Get the field ID and option ID for single select fields
        <span class="cov0" title="0">fields, err := c.GetProjectFields(projectID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get project fields: %w", err)
        }</span>

        <span class="cov0" title="0">var field *ProjectField
        for i := range fields </span><span class="cov0" title="0">{
                if fields[i].Name == fieldName </span><span class="cov0" title="0">{
                        field = &amp;fields[i]
                        break</span>
                }
        }

        <span class="cov0" title="0">if field == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("field %q not found in project", fieldName)
        }</span>

        // Handle different field types
        <span class="cov0" title="0">switch field.DataType </span>{
        case "SINGLE_SELECT":<span class="cov0" title="0">
                return c.setSingleSelectField(projectID, itemID, field, value)</span>
        case "TEXT":<span class="cov0" title="0">
                return c.setTextField(projectID, itemID, field.ID, value)</span>
        case "NUMBER":<span class="cov0" title="0">
                return c.setNumberField(projectID, itemID, field.ID, value)</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("unsupported field type: %s", field.DataType)</span>
        }
}

func (c *Client) setSingleSelectField(projectID, itemID string, field *ProjectField, value string) error <span class="cov0" title="0">{
        // Find the option ID for the value
        var optionID string
        for _, opt := range field.Options </span><span class="cov0" title="0">{
                if opt.Name == value </span><span class="cov0" title="0">{
                        optionID = opt.ID
                        break</span>
                }
        }

        <span class="cov0" title="0">if optionID == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("option %q not found for field %q", value, field.Name)
        }</span>

        <span class="cov0" title="0">var mutation struct {
                UpdateProjectV2ItemFieldValue struct {
                        ClientMutationID string `graphql:"clientMutationId"`
                } `graphql:"updateProjectV2ItemFieldValue(input: $input)"`
        }

        input := UpdateProjectV2ItemFieldValueInput{
                ProjectID: graphql.ID(projectID),
                ItemID:    graphql.ID(itemID),
                FieldID:   graphql.ID(field.ID),
                Value: ProjectV2FieldValue{
                        SingleSelectOptionId: graphql.String(optionID),
                },
        }

        variables := map[string]interface{}{
                "input": input,
        }

        err := c.gql.Mutate("UpdateProjectV2ItemFieldValue", &amp;mutation, variables)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to set field value: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (c *Client) setTextField(projectID, itemID, fieldID, value string) error <span class="cov0" title="0">{
        var mutation struct {
                UpdateProjectV2ItemFieldValue struct {
                        ClientMutationID string `graphql:"clientMutationId"`
                } `graphql:"updateProjectV2ItemFieldValue(input: $input)"`
        }

        input := UpdateProjectV2ItemFieldValueInput{
                ProjectID: graphql.ID(projectID),
                ItemID:    graphql.ID(itemID),
                FieldID:   graphql.ID(fieldID),
                Value: ProjectV2FieldValue{
                        Text: graphql.String(value),
                },
        }

        variables := map[string]interface{}{
                "input": input,
        }

        err := c.gql.Mutate("UpdateProjectV2ItemFieldValue", &amp;mutation, variables)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to set text field value: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (c *Client) setNumberField(projectID, itemID, fieldID, value string) error <span class="cov0" title="0">{
        var mutation struct {
                UpdateProjectV2ItemFieldValue struct {
                        ClientMutationID string `graphql:"clientMutationId"`
                } `graphql:"updateProjectV2ItemFieldValue(input: $input)"`
        }

        input := UpdateProjectV2ItemFieldValueInput{
                ProjectID: graphql.ID(projectID),
                ItemID:    graphql.ID(itemID),
                FieldID:   graphql.ID(fieldID),
                Value: ProjectV2FieldValue{
                        Number: graphql.Float(0), // TODO: parse value to float
                },
        }

        variables := map[string]interface{}{
                "input": input,
        }

        err := c.gql.Mutate("UpdateProjectV2ItemFieldValue", &amp;mutation, variables)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to set number field value: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// UpdateProjectV2ItemFieldValueInput represents the input for updating a field value
type UpdateProjectV2ItemFieldValueInput struct {
        ProjectID graphql.ID          `json:"projectId"`
        ItemID    graphql.ID          `json:"itemId"`
        FieldID   graphql.ID          `json:"fieldId"`
        Value     ProjectV2FieldValue `json:"value"`
}

// ProjectV2FieldValue represents a field value for a project item
type ProjectV2FieldValue struct {
        Text                 graphql.String `json:"text,omitempty"`
        Number               graphql.Float  `json:"number,omitempty"`
        Date                 graphql.String `json:"date,omitempty"`
        SingleSelectOptionId graphql.String `json:"singleSelectOptionId,omitempty"`
        IterationId          graphql.String `json:"iterationId,omitempty"`
}

// Helper methods

func (c *Client) getRepositoryID(owner, repo string) (string, error) <span class="cov0" title="0">{
        var query struct {
                Repository struct {
                        ID string
                } `graphql:"repository(owner: $owner, name: $repo)"`
        }

        variables := map[string]interface{}{
                "owner": graphql.String(owner),
                "repo":  graphql.String(repo),
        }

        err := c.gql.Query("GetRepositoryID", &amp;query, variables)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to get repository ID: %w", err)
        }</span>

        <span class="cov0" title="0">return query.Repository.ID, nil</span>
}

// AddSubIssue links a child issue as a sub-issue of a parent issue
func (c *Client) AddSubIssue(parentIssueID, childIssueID string) error <span class="cov0" title="0">{
        if c.gql == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("GraphQL client not initialized - are you authenticated with gh?")
        }</span>

        <span class="cov0" title="0">var mutation struct {
                AddSubIssue struct {
                        Issue struct {
                                ID string
                        }
                        SubIssue struct {
                                ID string
                        }
                } `graphql:"addSubIssue(input: $input)"`
        }

        input := AddSubIssueInput{
                IssueID:    graphql.ID(parentIssueID),
                SubIssueID: graphql.ID(childIssueID),
        }

        variables := map[string]interface{}{
                "input": input,
        }

        err := c.gql.Mutate("AddSubIssue", &amp;mutation, variables)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to add sub-issue: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// AddSubIssueInput represents the input for adding a sub-issue
type AddSubIssueInput struct {
        IssueID    graphql.ID `json:"issueId"`
        SubIssueID graphql.ID `json:"subIssueId"`
}

// RemoveSubIssue removes a child issue from its parent issue
func (c *Client) RemoveSubIssue(parentIssueID, childIssueID string) error <span class="cov0" title="0">{
        if c.gql == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("GraphQL client not initialized - are you authenticated with gh?")
        }</span>

        <span class="cov0" title="0">var mutation struct {
                RemoveSubIssue struct {
                        Issue struct {
                                ID string
                        }
                        SubIssue struct {
                                ID string
                        }
                } `graphql:"removeSubIssue(input: $input)"`
        }

        input := RemoveSubIssueInput{
                IssueID:    graphql.ID(parentIssueID),
                SubIssueID: graphql.ID(childIssueID),
        }

        variables := map[string]interface{}{
                "input": input,
        }

        err := c.gql.Mutate("RemoveSubIssue", &amp;mutation, variables)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to remove sub-issue: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// RemoveSubIssueInput represents the input for removing a sub-issue
type RemoveSubIssueInput struct {
        IssueID    graphql.ID `json:"issueId"`
        SubIssueID graphql.ID `json:"subIssueId"`
}

// AddLabelToIssue adds a label to an issue
func (c *Client) AddLabelToIssue(issueID, labelName string) error <span class="cov0" title="0">{
        if c.gql == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("GraphQL client not initialized - are you authenticated with gh?")
        }</span>

        // Note: This requires finding the label ID first, which needs the repository
        // For now, we'll skip this as it requires additional context
        // A full implementation would use addLabelsToLabelable mutation
        <span class="cov0" title="0">return nil</span>
}

func (c *Client) getLabelID(owner, repo, labelName string) (string, error) <span class="cov0" title="0">{
        var query struct {
                Repository struct {
                        Label struct {
                                ID string
                        } `graphql:"label(name: $labelName)"`
                } `graphql:"repository(owner: $owner, name: $repo)"`
        }

        variables := map[string]interface{}{
                "owner":     graphql.String(owner),
                "repo":      graphql.String(repo),
                "labelName": graphql.String(labelName),
        }

        err := c.gql.Query("GetLabelID", &amp;query, variables)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to get label ID: %w", err)
        }</span>

        <span class="cov0" title="0">if query.Repository.Label.ID == "" </span><span class="cov0" title="0">{
                return "", fmt.Errorf("label %q not found", labelName)
        }</span>

        <span class="cov0" title="0">return query.Repository.Label.ID, nil</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package api

import (
        "fmt"

        graphql "github.com/cli/shurcooL-graphql"
)

// GetProject fetches a project by owner and number
func (c *Client) GetProject(owner string, number int) (*Project, error) <span class="cov0" title="0">{
        if c.gql == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("GraphQL client not initialized - are you authenticated with gh?")
        }</span>

        // First try as user project
        <span class="cov0" title="0">project, err := c.getUserProject(owner, number)
        if err == nil </span><span class="cov0" title="0">{
                return project, nil
        }</span>

        // If that fails, try as organization project
        <span class="cov0" title="0">project, err = c.getOrgProject(owner, number)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get project %s/%d: %w", owner, number, err)
        }</span>

        <span class="cov0" title="0">return project, nil</span>
}

func (c *Client) getUserProject(owner string, number int) (*Project, error) <span class="cov0" title="0">{
        var query struct {
                User struct {
                        ProjectV2 struct {
                                ID     string
                                Number int
                                Title  string
                                URL    string `graphql:"url"`
                                Closed bool
                        } `graphql:"projectV2(number: $number)"`
                } `graphql:"user(login: $owner)"`
        }

        variables := map[string]interface{}{
                "owner":  graphql.String(owner),
                "number": graphql.Int(number),
        }

        err := c.gql.Query("GetUserProject", &amp;query, variables)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;Project{
                ID:     query.User.ProjectV2.ID,
                Number: query.User.ProjectV2.Number,
                Title:  query.User.ProjectV2.Title,
                URL:    query.User.ProjectV2.URL,
                Closed: query.User.ProjectV2.Closed,
                Owner: ProjectOwner{
                        Type:  "User",
                        Login: owner,
                },
        }, nil</span>
}

func (c *Client) getOrgProject(owner string, number int) (*Project, error) <span class="cov0" title="0">{
        var query struct {
                Organization struct {
                        ProjectV2 struct {
                                ID     string
                                Number int
                                Title  string
                                URL    string `graphql:"url"`
                                Closed bool
                        } `graphql:"projectV2(number: $number)"`
                } `graphql:"organization(login: $owner)"`
        }

        variables := map[string]interface{}{
                "owner":  graphql.String(owner),
                "number": graphql.Int(number),
        }

        err := c.gql.Query("GetOrgProject", &amp;query, variables)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;Project{
                ID:     query.Organization.ProjectV2.ID,
                Number: query.Organization.ProjectV2.Number,
                Title:  query.Organization.ProjectV2.Title,
                URL:    query.Organization.ProjectV2.URL,
                Closed: query.Organization.ProjectV2.Closed,
                Owner: ProjectOwner{
                        Type:  "Organization",
                        Login: owner,
                },
        }, nil</span>
}

// GetProjectFields fetches all fields for a project
func (c *Client) GetProjectFields(projectID string) ([]ProjectField, error) <span class="cov0" title="0">{
        if c.gql == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("GraphQL client not initialized - are you authenticated with gh?")
        }</span>

        <span class="cov0" title="0">var query struct {
                Node struct {
                        ProjectV2 struct {
                                Fields struct {
                                        Nodes []struct {
                                                TypeName string `graphql:"__typename"`
                                                // Common fields
                                                ProjectV2Field struct {
                                                        ID       string
                                                        Name     string
                                                        DataType string
                                                } `graphql:"... on ProjectV2Field"`
                                                // Single select fields have options
                                                ProjectV2SingleSelectField struct {
                                                        ID       string
                                                        Name     string
                                                        DataType string
                                                        Options  []struct {
                                                                ID   string
                                                                Name string
                                                        }
                                                } `graphql:"... on ProjectV2SingleSelectField"`
                                        }
                                } `graphql:"fields(first: 50)"`
                        } `graphql:"... on ProjectV2"`
                } `graphql:"node(id: $projectId)"`
        }

        variables := map[string]interface{}{
                "projectId": graphql.ID(projectID),
        }

        err := c.gql.Query("GetProjectFields", &amp;query, variables)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get project fields: %w", err)
        }</span>

        <span class="cov0" title="0">var fields []ProjectField
        for _, node := range query.Node.ProjectV2.Fields.Nodes </span><span class="cov0" title="0">{
                field := ProjectField{}

                switch node.TypeName </span>{
                case "ProjectV2SingleSelectField":<span class="cov0" title="0">
                        field.ID = node.ProjectV2SingleSelectField.ID
                        field.Name = node.ProjectV2SingleSelectField.Name
                        field.DataType = node.ProjectV2SingleSelectField.DataType
                        for _, opt := range node.ProjectV2SingleSelectField.Options </span><span class="cov0" title="0">{
                                field.Options = append(field.Options, FieldOption{
                                        ID:   opt.ID,
                                        Name: opt.Name,
                                })
                        }</span>
                case "ProjectV2Field":<span class="cov0" title="0">
                        field.ID = node.ProjectV2Field.ID
                        field.Name = node.ProjectV2Field.Name
                        field.DataType = node.ProjectV2Field.DataType</span>
                default:<span class="cov0" title="0">
                        // Skip iteration/other field types for now
                        continue</span>
                }

                <span class="cov0" title="0">fields = append(fields, field)</span>
        }

        <span class="cov0" title="0">return fields, nil</span>
}

// GetIssue fetches an issue by repository and number
func (c *Client) GetIssue(owner, repo string, number int) (*Issue, error) <span class="cov0" title="0">{
        if c.gql == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("GraphQL client not initialized - are you authenticated with gh?")
        }</span>

        <span class="cov0" title="0">var query struct {
                Repository struct {
                        Issue struct {
                                ID     string
                                Number int
                                Title  string
                                Body   string
                                State  string
                                URL    string `graphql:"url"`
                                Author struct {
                                        Login string
                                }
                                Assignees struct {
                                        Nodes []struct {
                                                Login string
                                        }
                                } `graphql:"assignees(first: 10)"`
                                Labels struct {
                                        Nodes []struct {
                                                Name  string
                                                Color string
                                        }
                                } `graphql:"labels(first: 20)"`
                                Milestone struct {
                                        Title string
                                }
                        } `graphql:"issue(number: $number)"`
                } `graphql:"repository(owner: $owner, name: $repo)"`
        }

        variables := map[string]interface{}{
                "owner":  graphql.String(owner),
                "repo":   graphql.String(repo),
                "number": graphql.Int(number),
        }

        err := c.gql.Query("GetIssue", &amp;query, variables)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get issue %s/%s#%d: %w", owner, repo, number, err)
        }</span>

        <span class="cov0" title="0">issue := &amp;Issue{
                ID:     query.Repository.Issue.ID,
                Number: query.Repository.Issue.Number,
                Title:  query.Repository.Issue.Title,
                Body:   query.Repository.Issue.Body,
                State:  query.Repository.Issue.State,
                URL:    query.Repository.Issue.URL,
                Repository: Repository{
                        Owner: owner,
                        Name:  repo,
                },
                Author: Actor{Login: query.Repository.Issue.Author.Login},
        }

        for _, a := range query.Repository.Issue.Assignees.Nodes </span><span class="cov0" title="0">{
                issue.Assignees = append(issue.Assignees, Actor{Login: a.Login})
        }</span>

        <span class="cov0" title="0">for _, l := range query.Repository.Issue.Labels.Nodes </span><span class="cov0" title="0">{
                issue.Labels = append(issue.Labels, Label{Name: l.Name, Color: l.Color})
        }</span>

        <span class="cov0" title="0">if query.Repository.Issue.Milestone.Title != "" </span><span class="cov0" title="0">{
                issue.Milestone = &amp;Milestone{Title: query.Repository.Issue.Milestone.Title}
        }</span>

        <span class="cov0" title="0">return issue, nil</span>
}

// ProjectItemsFilter allows filtering project items
type ProjectItemsFilter struct {
        Repository string // Filter by repository (owner/repo format)
}

// GetProjectItems fetches all items from a project with their field values
func (c *Client) GetProjectItems(projectID string, filter *ProjectItemsFilter) ([]ProjectItem, error) <span class="cov0" title="0">{
        if c.gql == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("GraphQL client not initialized - are you authenticated with gh?")
        }</span>

        <span class="cov0" title="0">var query struct {
                Node struct {
                        ProjectV2 struct {
                                Items struct {
                                        Nodes []struct {
                                                ID      string
                                                Content struct {
                                                        TypeName string `graphql:"__typename"`
                                                        Issue    struct {
                                                                ID         string
                                                                Number     int
                                                                Title      string
                                                                State      string
                                                                URL        string `graphql:"url"`
                                                                Repository struct {
                                                                        NameWithOwner string
                                                                }
                                                                Assignees struct {
                                                                        Nodes []struct {
                                                                                Login string
                                                                        }
                                                                } `graphql:"assignees(first: 10)"`
                                                        } `graphql:"... on Issue"`
                                                }
                                                FieldValues struct {
                                                        Nodes []struct {
                                                                TypeName string `graphql:"__typename"`
                                                                // Single select field value
                                                                ProjectV2ItemFieldSingleSelectValue struct {
                                                                        Name  string
                                                                        Field struct {
                                                                                ProjectV2SingleSelectField struct {
                                                                                        Name string
                                                                                } `graphql:"... on ProjectV2SingleSelectField"`
                                                                        }
                                                                } `graphql:"... on ProjectV2ItemFieldSingleSelectValue"`
                                                                // Text field value
                                                                ProjectV2ItemFieldTextValue struct {
                                                                        Text  string
                                                                        Field struct {
                                                                                ProjectV2Field struct {
                                                                                        Name string
                                                                                } `graphql:"... on ProjectV2Field"`
                                                                        }
                                                                } `graphql:"... on ProjectV2ItemFieldTextValue"`
                                                        }
                                                } `graphql:"fieldValues(first: 20)"`
                                        }
                                } `graphql:"items(first: 100)"`
                        } `graphql:"... on ProjectV2"`
                } `graphql:"node(id: $projectId)"`
        }

        variables := map[string]interface{}{
                "projectId": graphql.ID(projectID),
        }

        err := c.gql.Query("GetProjectItems", &amp;query, variables)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get project items: %w", err)
        }</span>

        <span class="cov0" title="0">var items []ProjectItem
        for _, node := range query.Node.ProjectV2.Items.Nodes </span><span class="cov0" title="0">{
                // Skip non-issue items (like draft issues or PRs)
                if node.Content.TypeName != "Issue" </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Apply repository filter if specified
                <span class="cov0" title="0">if filter != nil &amp;&amp; filter.Repository != "" </span><span class="cov0" title="0">{
                        if node.Content.Issue.Repository.NameWithOwner != filter.Repository </span><span class="cov0" title="0">{
                                continue</span>
                        }
                }

                <span class="cov0" title="0">item := ProjectItem{
                        ID: node.ID,
                        Issue: &amp;Issue{
                                ID:     node.Content.Issue.ID,
                                Number: node.Content.Issue.Number,
                                Title:  node.Content.Issue.Title,
                                State:  node.Content.Issue.State,
                                URL:    node.Content.Issue.URL,
                        },
                }

                // Parse repository
                if node.Content.Issue.Repository.NameWithOwner != "" </span><span class="cov0" title="0">{
                        parts := splitRepoName(node.Content.Issue.Repository.NameWithOwner)
                        if len(parts) == 2 </span><span class="cov0" title="0">{
                                item.Issue.Repository = Repository{
                                        Owner: parts[0],
                                        Name:  parts[1],
                                }
                        }</span>
                }

                // Parse assignees
                <span class="cov0" title="0">for _, a := range node.Content.Issue.Assignees.Nodes </span><span class="cov0" title="0">{
                        item.Issue.Assignees = append(item.Issue.Assignees, Actor{Login: a.Login})
                }</span>

                // Parse field values
                <span class="cov0" title="0">for _, fv := range node.FieldValues.Nodes </span><span class="cov0" title="0">{
                        switch fv.TypeName </span>{
                        case "ProjectV2ItemFieldSingleSelectValue":<span class="cov0" title="0">
                                if fv.ProjectV2ItemFieldSingleSelectValue.Name != "" </span><span class="cov0" title="0">{
                                        item.FieldValues = append(item.FieldValues, FieldValue{
                                                Field: fv.ProjectV2ItemFieldSingleSelectValue.Field.ProjectV2SingleSelectField.Name,
                                                Value: fv.ProjectV2ItemFieldSingleSelectValue.Name,
                                        })
                                }</span>
                        case "ProjectV2ItemFieldTextValue":<span class="cov0" title="0">
                                if fv.ProjectV2ItemFieldTextValue.Text != "" </span><span class="cov0" title="0">{
                                        item.FieldValues = append(item.FieldValues, FieldValue{
                                                Field: fv.ProjectV2ItemFieldTextValue.Field.ProjectV2Field.Name,
                                                Value: fv.ProjectV2ItemFieldTextValue.Text,
                                        })
                                }</span>
                        }
                }

                <span class="cov0" title="0">items = append(items, item)</span>
        }

        <span class="cov0" title="0">return items, nil</span>
}

// splitRepoName splits "owner/repo" into parts
func splitRepoName(nameWithOwner string) []string <span class="cov0" title="0">{
        for i, c := range nameWithOwner </span><span class="cov0" title="0">{
                if c == '/' </span><span class="cov0" title="0">{
                        return []string{nameWithOwner[:i], nameWithOwner[i+1:]}
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// GetSubIssues fetches all sub-issues for a given issue
func (c *Client) GetSubIssues(owner, repo string, number int) ([]SubIssue, error) <span class="cov0" title="0">{
        if c.gql == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("GraphQL client not initialized - are you authenticated with gh?")
        }</span>

        <span class="cov0" title="0">var query struct {
                Repository struct {
                        Issue struct {
                                SubIssues struct {
                                        Nodes []struct {
                                                ID         string
                                                Number     int
                                                Title      string
                                                State      string
                                                URL        string `graphql:"url"`
                                                Repository struct {
                                                        Name  string
                                                        Owner struct {
                                                                Login string
                                                        }
                                                }
                                        }
                                } `graphql:"subIssues(first: 50)"`
                        } `graphql:"issue(number: $number)"`
                } `graphql:"repository(owner: $owner, name: $repo)"`
        }

        variables := map[string]interface{}{
                "owner":  graphql.String(owner),
                "repo":   graphql.String(repo),
                "number": graphql.Int(number),
        }

        err := c.gql.Query("GetSubIssues", &amp;query, variables)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get sub-issues for %s/%s#%d: %w", owner, repo, number, err)
        }</span>

        <span class="cov0" title="0">var subIssues []SubIssue
        for _, node := range query.Repository.Issue.SubIssues.Nodes </span><span class="cov0" title="0">{
                subIssues = append(subIssues, SubIssue{
                        ID:     node.ID,
                        Number: node.Number,
                        Title:  node.Title,
                        State:  node.State,
                        URL:    node.URL,
                        Repository: Repository{
                                Owner: node.Repository.Owner.Login,
                                Name:  node.Repository.Name,
                        },
                })
        }</span>

        <span class="cov0" title="0">return subIssues, nil</span>
}

// GetRepositoryIssues fetches issues from a repository with the given state filter
func (c *Client) GetRepositoryIssues(owner, repo, state string) ([]Issue, error) <span class="cov0" title="0">{
        if c.gql == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("GraphQL client not initialized - are you authenticated with gh?")
        }</span>

        // Map state to GraphQL enum values
        <span class="cov0" title="0">var states []graphql.String
        switch state </span>{
        case "open":<span class="cov0" title="0">
                states = []graphql.String{"OPEN"}</span>
        case "closed":<span class="cov0" title="0">
                states = []graphql.String{"CLOSED"}</span>
        case "all", "":<span class="cov0" title="0">
                states = []graphql.String{"OPEN", "CLOSED"}</span>
        default:<span class="cov0" title="0">
                states = []graphql.String{graphql.String(state)}</span>
        }

        <span class="cov0" title="0">var query struct {
                Repository struct {
                        Issues struct {
                                Nodes []struct {
                                        ID     string
                                        Number int
                                        Title  string
                                        State  string
                                        URL    string `graphql:"url"`
                                }
                                PageInfo struct {
                                        HasNextPage bool
                                        EndCursor   string
                                }
                        } `graphql:"issues(first: 100, states: $states)"`
                } `graphql:"repository(owner: $owner, name: $repo)"`
        }

        variables := map[string]interface{}{
                "owner":  graphql.String(owner),
                "repo":   graphql.String(repo),
                "states": states,
        }

        err := c.gql.Query("GetRepositoryIssues", &amp;query, variables)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get issues from %s/%s: %w", owner, repo, err)
        }</span>

        <span class="cov0" title="0">var issues []Issue
        for _, node := range query.Repository.Issues.Nodes </span><span class="cov0" title="0">{
                issues = append(issues, Issue{
                        ID:     node.ID,
                        Number: node.Number,
                        Title:  node.Title,
                        State:  node.State,
                        URL:    node.URL,
                        Repository: Repository{
                                Owner: owner,
                                Name:  repo,
                        },
                })
        }</span>

        <span class="cov0" title="0">return issues, nil</span>
}

// GetParentIssue fetches the parent issue for a given sub-issue
func (c *Client) GetParentIssue(owner, repo string, number int) (*Issue, error) <span class="cov0" title="0">{
        if c.gql == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("GraphQL client not initialized - are you authenticated with gh?")
        }</span>

        <span class="cov0" title="0">var query struct {
                Repository struct {
                        Issue struct {
                                Parent struct {
                                        ID     string
                                        Number int
                                        Title  string
                                        State  string
                                        URL    string `graphql:"url"`
                                } `graphql:"parent"`
                        } `graphql:"issue(number: $number)"`
                } `graphql:"repository(owner: $owner, name: $repo)"`
        }

        variables := map[string]interface{}{
                "owner":  graphql.String(owner),
                "repo":   graphql.String(repo),
                "number": graphql.Int(number),
        }

        err := c.gql.Query("GetParentIssue", &amp;query, variables)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get parent issue for %s/%s#%d: %w", owner, repo, number, err)
        }</span>

        // If no parent issue, return nil
        <span class="cov0" title="0">if query.Repository.Issue.Parent.ID == "" </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        <span class="cov0" title="0">return &amp;Issue{
                ID:     query.Repository.Issue.Parent.ID,
                Number: query.Repository.Issue.Parent.Number,
                Title:  query.Repository.Issue.Parent.Title,
                State:  query.Repository.Issue.Parent.State,
                URL:    query.Repository.Issue.Parent.URL,
        }, nil</span>
}

// ListProjects fetches all projects for an owner (user or organization)
func (c *Client) ListProjects(owner string) ([]Project, error) <span class="cov0" title="0">{
        if c.gql == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("GraphQL client not initialized - are you authenticated with gh?")
        }</span>

        // First try as user projects
        <span class="cov0" title="0">projects, err := c.listUserProjects(owner)
        if err == nil &amp;&amp; len(projects) &gt; 0 </span><span class="cov0" title="0">{
                return projects, nil
        }</span>

        // If that fails or returns empty, try as organization projects
        <span class="cov0" title="0">orgProjects, err := c.listOrgProjects(owner)
        if err != nil </span><span class="cov0" title="0">{
                // If both fail, return user error if we had one
                if projects != nil </span><span class="cov0" title="0">{
                        return projects, nil
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to list projects for %s: %w", owner, err)</span>
        }

        <span class="cov0" title="0">return orgProjects, nil</span>
}

func (c *Client) listUserProjects(owner string) ([]Project, error) <span class="cov0" title="0">{
        var query struct {
                User struct {
                        ProjectsV2 struct {
                                Nodes []struct {
                                        ID     string
                                        Number int
                                        Title  string
                                        URL    string `graphql:"url"`
                                        Closed bool
                                }
                        } `graphql:"projectsV2(first: 20, orderBy: {field: UPDATED_AT, direction: DESC})"`
                } `graphql:"user(login: $owner)"`
        }

        variables := map[string]interface{}{
                "owner": graphql.String(owner),
        }

        err := c.gql.Query("ListUserProjects", &amp;query, variables)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var projects []Project
        for _, node := range query.User.ProjectsV2.Nodes </span><span class="cov0" title="0">{
                if node.Closed </span><span class="cov0" title="0">{
                        continue</span> // Skip closed projects
                }
                <span class="cov0" title="0">projects = append(projects, Project{
                        ID:     node.ID,
                        Number: node.Number,
                        Title:  node.Title,
                        URL:    node.URL,
                        Closed: node.Closed,
                        Owner: ProjectOwner{
                                Type:  "User",
                                Login: owner,
                        },
                })</span>
        }

        <span class="cov0" title="0">return projects, nil</span>
}

func (c *Client) listOrgProjects(owner string) ([]Project, error) <span class="cov0" title="0">{
        var query struct {
                Organization struct {
                        ProjectsV2 struct {
                                Nodes []struct {
                                        ID     string
                                        Number int
                                        Title  string
                                        URL    string `graphql:"url"`
                                        Closed bool
                                }
                        } `graphql:"projectsV2(first: 20, orderBy: {field: UPDATED_AT, direction: DESC})"`
                } `graphql:"organization(login: $owner)"`
        }

        variables := map[string]interface{}{
                "owner": graphql.String(owner),
        }

        err := c.gql.Query("ListOrgProjects", &amp;query, variables)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var projects []Project
        for _, node := range query.Organization.ProjectsV2.Nodes </span><span class="cov0" title="0">{
                if node.Closed </span><span class="cov0" title="0">{
                        continue</span> // Skip closed projects
                }
                <span class="cov0" title="0">projects = append(projects, Project{
                        ID:     node.ID,
                        Number: node.Number,
                        Title:  node.Title,
                        URL:    node.URL,
                        Closed: node.Closed,
                        Owner: ProjectOwner{
                                Type:  "Organization",
                                Login: owner,
                        },
                })</span>
        }

        <span class="cov0" title="0">return projects, nil</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package config

import (
        "fmt"
        "os"
        "path/filepath"
        "strconv"

        "gopkg.in/yaml.v3"
)

// Config represents the .gh-pmu.yml configuration file
type Config struct {
        Project      Project           `yaml:"project"`
        Repositories []string          `yaml:"repositories"`
        Defaults     Defaults          `yaml:"defaults,omitempty"`
        Fields       map[string]Field  `yaml:"fields,omitempty"`
        Triage       map[string]Triage `yaml:"triage,omitempty"`
        Metadata     *Metadata         `yaml:"metadata,omitempty"`
}

// Project contains GitHub project configuration
type Project struct {
        Name   string `yaml:"name,omitempty"`
        Number int    `yaml:"number"`
        Owner  string `yaml:"owner"`
}

// Defaults contains default values for new issues
type Defaults struct {
        Priority string   `yaml:"priority,omitempty"`
        Status   string   `yaml:"status,omitempty"`
        Labels   []string `yaml:"labels,omitempty"`
}

// Field maps field aliases to GitHub project field names and values
type Field struct {
        Field  string            `yaml:"field"`
        Values map[string]string `yaml:"values,omitempty"`
}

// Triage contains configuration for triage rules
type Triage struct {
        Query       string            `yaml:"query"`
        Apply       TriageApply       `yaml:"apply,omitempty"`
        Interactive TriageInteractive `yaml:"interactive,omitempty"`
}

// TriageApply contains fields to apply during triage
type TriageApply struct {
        Labels []string          `yaml:"labels,omitempty"`
        Fields map[string]string `yaml:"fields,omitempty"`
}

// TriageInteractive contains interactive prompts for triage
type TriageInteractive struct {
        Status   bool `yaml:"status,omitempty"`
        Estimate bool `yaml:"estimate,omitempty"`
}

// Metadata contains cached project metadata from GitHub API
type Metadata struct {
        Project ProjectMetadata `yaml:"project,omitempty"`
        Fields  []FieldMetadata `yaml:"fields,omitempty"`
}

// ProjectMetadata contains cached project info
type ProjectMetadata struct {
        ID string `yaml:"id,omitempty"`
}

// FieldMetadata contains cached field info
type FieldMetadata struct {
        Name     string           `yaml:"name"`
        ID       string           `yaml:"id"`
        DataType string           `yaml:"data_type"`
        Options  []OptionMetadata `yaml:"options,omitempty"`
}

// OptionMetadata contains cached field option info
type OptionMetadata struct {
        Name string `yaml:"name"`
        ID   string `yaml:"id"`
}

// ConfigFileName is the default configuration file name
const ConfigFileName = ".gh-pmu.yml"

// Load reads and parses a configuration file from the given path
func Load(path string) (*Config, error) <span class="cov10" title="6">{
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov4" title="2">{
                return nil, fmt.Errorf("failed to read config file: %w", err)
        }</span>

        <span class="cov7" title="4">var cfg Config
        if err := yaml.Unmarshal(data, &amp;cfg); err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to parse config file: %w", err)
        }</span>

        <span class="cov6" title="3">return &amp;cfg, nil</span>
}

// LoadFromDirectory finds and loads the config file from the given directory
func LoadFromDirectory(dir string) (*Config, error) <span class="cov4" title="2">{
        path := filepath.Join(dir, ConfigFileName)
        return Load(path)
}</span>

// Validate checks that required configuration fields are present
func (c *Config) Validate() error <span class="cov7" title="4">{
        if c.Project.Owner == "" </span><span class="cov1" title="1">{
                return fmt.Errorf("project.owner is required")
        }</span>

        <span class="cov6" title="3">if c.Project.Number == 0 </span><span class="cov1" title="1">{
                return fmt.Errorf("project.number is required")
        }</span>

        <span class="cov4" title="2">if len(c.Repositories) == 0 </span><span class="cov1" title="1">{
                return fmt.Errorf("at least one repository is required")
        }</span>

        <span class="cov1" title="1">return nil</span>
}

// ResolveFieldValue maps an alias to its actual GitHub field value.
// If no alias is found, returns the original value unchanged.
func (c *Config) ResolveFieldValue(fieldKey, alias string) string <span class="cov6" title="3">{
        field, ok := c.Fields[fieldKey]
        if !ok </span><span class="cov1" title="1">{
                return alias
        }</span>

        <span class="cov4" title="2">if actual, ok := field.Values[alias]; ok </span><span class="cov1" title="1">{
                return actual
        }</span>

        <span class="cov1" title="1">return alias</span>
}

// GetFieldName returns the actual GitHub field name for a given key.
// If no mapping exists, returns the original key unchanged.
func (c *Config) GetFieldName(fieldKey string) string <span class="cov4" title="2">{
        field, ok := c.Fields[fieldKey]
        if !ok </span><span class="cov1" title="1">{
                return fieldKey
        }</span>

        <span class="cov1" title="1">if field.Field != "" </span><span class="cov1" title="1">{
                return field.Field
        }</span>

        <span class="cov0" title="0">return fieldKey</span>
}

// ApplyEnvOverrides applies environment variable overrides to the config.
// Supported environment variables:
//   - GH_PM_PROJECT_OWNER: overrides project.owner
//   - GH_PM_PROJECT_NUMBER: overrides project.number
func (c *Config) ApplyEnvOverrides() <span class="cov7" title="4">{
        if owner := os.Getenv("GH_PM_PROJECT_OWNER"); owner != "" </span><span class="cov1" title="1">{
                c.Project.Owner = owner
        }</span>

        <span class="cov7" title="4">if numberStr := os.Getenv("GH_PM_PROJECT_NUMBER"); numberStr != "" </span><span class="cov4" title="2">{
                if number, err := strconv.Atoi(numberStr); err == nil </span><span class="cov1" title="1">{
                        c.Project.Number = number
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file15" style="display: none">// Package ui provides styled terminal output helpers for gh-pmu.
package ui

import (
        "fmt"
        "io"
        "strings"
        "sync"
        "time"
)

// ANSI color codes
const (
        Reset   = "\033[0m"
        Bold    = "\033[1m"
        Dim     = "\033[2m"
        Red     = "\033[31m"
        Green   = "\033[32m"
        Yellow  = "\033[33m"
        Blue    = "\033[34m"
        Magenta = "\033[35m"
        Cyan    = "\033[36m"
        White   = "\033[37m"
)

// Box style characters
const (
        BoxTopLeft        = ""
        BoxTopRight       = ""
        BoxBottomLeft     = ""
        BoxBottomRight    = ""
        BoxHorizontal     = ""
        BoxVertical       = ""
        BoxTopLeftAlt     = ""
        BoxTopRightAlt    = ""
        BoxBottomLeftAlt  = ""
        BoxBottomRightAlt = ""
)

// Symbols for status indicators
const (
        SymbolCheck   = ""
        SymbolCross   = ""
        SymbolWarning = ""
        SymbolInfo    = ""
        SymbolArrow   = ""
)

// Spinner frames for loading animation
var SpinnerFrames = []string{"", "", "", "", "", "", "", "", "", ""}

// UI provides styled terminal output
type UI struct {
        out     io.Writer
        noColor bool
}

// New creates a new UI instance
func New(out io.Writer) *UI <span class="cov4" title="14">{
        return &amp;UI{
                out:     out,
                noColor: false,
        }
}</span>

// NewWithOptions creates a new UI with options
func NewWithOptions(out io.Writer, noColor bool) *UI <span class="cov1" title="1">{
        return &amp;UI{
                out:     out,
                noColor: noColor,
        }
}</span>

// color wraps text in ANSI color codes if color is enabled
func (u *UI) color(c, text string) string <span class="cov6" title="54">{
        if u.noColor </span><span class="cov1" title="1">{
                return text
        }</span>
        <span class="cov6" title="53">return c + text + Reset</span>
}

// Success prints a green checkmark with message
func (u *UI) Success(msg string) <span class="cov1" title="2">{
        fmt.Fprintf(u.out, "%s %s\n", u.color(Green, SymbolCheck), msg)
}</span>

// Error prints a red cross with message
func (u *UI) Error(msg string) <span class="cov1" title="1">{
        fmt.Fprintf(u.out, "%s %s\n", u.color(Red, SymbolCross), msg)
}</span>

// Warning prints a yellow warning with message
func (u *UI) Warning(msg string) <span class="cov1" title="1">{
        fmt.Fprintf(u.out, "%s %s\n", u.color(Yellow, SymbolWarning), msg)
}</span>

// Info prints an info symbol with message
func (u *UI) Info(msg string) <span class="cov1" title="1">{
        fmt.Fprintf(u.out, "%s %s\n", u.color(Cyan, SymbolInfo), msg)
}</span>

// Step prints a step indicator (e.g., "Step 1 of 3: Title")
func (u *UI) Step(current, total int, title string) <span class="cov1" title="1">{
        fmt.Fprintf(u.out, "\n%s\n", u.color(Bold+Cyan, fmt.Sprintf("Step %d of %d: %s", current, total, title)))
}</span>

// Header prints a styled header box
func (u *UI) Header(title, subtitle string) <span class="cov1" title="2">{
        width := max(len(title), len(subtitle)) + 4
        if width &lt; 40 </span><span class="cov1" title="2">{
                width = 40
        }</span>

        // Top border
        <span class="cov1" title="2">fmt.Fprintf(u.out, "%s%s%s\n",
                u.color(Cyan, BoxTopLeft),
                u.color(Cyan, strings.Repeat(BoxHorizontal, width)),
                u.color(Cyan, BoxTopRight))

        // Title line
        titlePadding := width - len(title) - 2
        fmt.Fprintf(u.out, "%s  %s%s%s\n",
                u.color(Cyan, BoxVertical),
                u.color(Bold+White, title),
                strings.Repeat(" ", titlePadding),
                u.color(Cyan, BoxVertical))

        // Subtitle line
        if subtitle != "" </span><span class="cov1" title="1">{
                subtitlePadding := width - len(subtitle) - 2
                fmt.Fprintf(u.out, "%s  %s%s%s\n",
                        u.color(Cyan, BoxVertical),
                        u.color(Dim+White, subtitle),
                        strings.Repeat(" ", subtitlePadding),
                        u.color(Cyan, BoxVertical))
        }</span>

        // Bottom border
        <span class="cov1" title="2">fmt.Fprintf(u.out, "%s%s%s\n",
                u.color(Cyan, BoxBottomLeft),
                u.color(Cyan, strings.Repeat(BoxHorizontal, width)),
                u.color(Cyan, BoxBottomRight))</span>
}

// Box prints content in a box
func (u *UI) Box(lines []string) <span class="cov1" title="2">{
        if len(lines) == 0 </span><span class="cov1" title="1">{
                return
        }</span>

        // Find max visible width (without ANSI codes)
        <span class="cov1" title="1">maxWidth := 0
        for _, line := range lines </span><span class="cov2" title="3">{
                visible := len(stripANSI(line))
                if visible &gt; maxWidth </span><span class="cov1" title="1">{
                        maxWidth = visible
                }</span>
        }
        <span class="cov1" title="1">width := maxWidth + 4
        if width &lt; 40 </span><span class="cov1" title="1">{
                width = 40
        }</span>

        // Top border
        <span class="cov1" title="1">fmt.Fprintf(u.out, "%s%s%s\n",
                BoxTopLeftAlt,
                strings.Repeat(BoxHorizontal, width),
                BoxTopRightAlt)

        // Content lines
        for _, line := range lines </span><span class="cov2" title="3">{
                visible := len(stripANSI(line))
                padding := width - visible - 2
                if padding &lt; 0 </span><span class="cov0" title="0">{
                        padding = 0
                }</span>
                <span class="cov2" title="3">fmt.Fprintf(u.out, "%s  %s%s%s\n",
                        BoxVertical,
                        line,
                        strings.Repeat(" ", padding),
                        BoxVertical)</span>
        }

        // Bottom border
        <span class="cov1" title="1">fmt.Fprintf(u.out, "%s%s%s\n",
                BoxBottomLeftAlt,
                strings.Repeat(BoxHorizontal, width),
                BoxBottomRightAlt)</span>
}

// SummaryBox prints a styled summary box with key-value pairs
func (u *UI) SummaryBox(title string, items map[string]string, order []string) <span class="cov1" title="1">{
        // Calculate widths
        maxKeyLen := 0
        maxValLen := 0
        for _, key := range order </span><span class="cov1" title="2">{
                if len(key) &gt; maxKeyLen </span><span class="cov1" title="1">{
                        maxKeyLen = len(key)
                }</span>
                <span class="cov1" title="2">if val, ok := items[key]; ok &amp;&amp; len(val) &gt; maxValLen </span><span class="cov1" title="1">{
                        maxValLen = len(val)
                }</span>
        }

        // Build lines
        <span class="cov1" title="1">var lines []string
        lines = append(lines, u.color(Green, SymbolCheck)+" "+u.color(Bold, title))
        lines = append(lines, "")

        for _, key := range order </span><span class="cov1" title="2">{
                if val, ok := items[key]; ok </span><span class="cov1" title="2">{
                        keyPadded := key + ":" + strings.Repeat(" ", maxKeyLen-len(key)+1)
                        lines = append(lines, u.color(Dim, keyPadded)+val)
                }</span>
        }

        // Find max visible width (without ANSI codes)
        <span class="cov1" title="1">maxWidth := 0
        for _, line := range lines </span><span class="cov2" title="4">{
                visible := stripANSI(line)
                if len(visible) &gt; maxWidth </span><span class="cov1" title="1">{
                        maxWidth = len(visible)
                }</span>
        }
        <span class="cov1" title="1">width := maxWidth + 4
        if width &lt; 40 </span><span class="cov1" title="1">{
                width = 40
        }</span>

        // Top border
        <span class="cov1" title="1">fmt.Fprintf(u.out, "\n%s%s%s\n",
                u.color(Green, BoxTopLeft),
                u.color(Green, strings.Repeat(BoxHorizontal, width)),
                u.color(Green, BoxTopRight))

        // Content lines
        for _, line := range lines </span><span class="cov2" title="4">{
                visible := stripANSI(line)
                padding := width - len(visible) - 2
                if padding &lt; 0 </span><span class="cov0" title="0">{
                        padding = 0
                }</span>
                <span class="cov2" title="4">fmt.Fprintf(u.out, "%s  %s%s%s\n",
                        u.color(Green, BoxVertical),
                        line,
                        strings.Repeat(" ", padding),
                        u.color(Green, BoxVertical))</span>
        }

        // Bottom border
        <span class="cov1" title="1">fmt.Fprintf(u.out, "%s%s%s\n",
                u.color(Green, BoxBottomLeft),
                u.color(Green, strings.Repeat(BoxHorizontal, width)),
                u.color(Green, BoxBottomRight))</span>
}

// Menu prints a selection menu and returns formatted lines
func (u *UI) Menu(options []string, includeManualOption bool) []string <span class="cov1" title="2">{
        var lines []string
        for i, opt := range options </span><span class="cov2" title="4">{
                lines = append(lines, fmt.Sprintf("  %s %s", u.color(Cyan, fmt.Sprintf("%d.", i+1)), opt))
        }</span>
        <span class="cov1" title="2">if includeManualOption </span><span class="cov1" title="1">{
                lines = append(lines, fmt.Sprintf("  %s %s", u.color(Dim, "0."), u.color(Dim, "Enter project number manually")))
        }</span>
        <span class="cov1" title="2">return lines</span>
}

// PrintMenu prints a menu with a box
func (u *UI) PrintMenu(options []string, includeManualOption bool) <span class="cov0" title="0">{
        menuLines := u.Menu(options, includeManualOption)
        u.Box(menuLines)
}</span>

// Prompt prints a prompt and returns the formatted string
func (u *UI) Prompt(label string, defaultVal string) string <span class="cov1" title="2">{
        if defaultVal != "" </span><span class="cov1" title="1">{
                return fmt.Sprintf("%s [%s]: ", u.color(Cyan, label), u.color(Dim, defaultVal))
        }</span>
        <span class="cov1" title="1">return fmt.Sprintf("%s: ", u.color(Cyan, label))</span>
}

// Spinner provides an animated loading indicator
type Spinner struct {
        mu       sync.Mutex
        out      io.Writer
        message  string
        active   bool
        stopCh   chan struct{}
        doneCh   chan struct{}
        frameIdx int
}

// NewSpinner creates a new spinner
func NewSpinner(out io.Writer, message string) *Spinner <span class="cov0" title="0">{
        return &amp;Spinner{
                out:     out,
                message: message,
                stopCh:  make(chan struct{}),
                doneCh:  make(chan struct{}),
        }
}</span>

// Start begins the spinner animation
func (s *Spinner) Start() <span class="cov0" title="0">{
        s.mu.Lock()
        if s.active </span><span class="cov0" title="0">{
                s.mu.Unlock()
                return
        }</span>
        <span class="cov0" title="0">s.active = true
        s.mu.Unlock()

        go func() </span><span class="cov0" title="0">{
                ticker := time.NewTicker(80 * time.Millisecond)
                defer ticker.Stop()
                defer close(s.doneCh)

                for </span><span class="cov0" title="0">{
                        select </span>{
                        case &lt;-s.stopCh:<span class="cov0" title="0">
                                // Clear the spinner line
                                fmt.Fprintf(s.out, "\r%s\r", strings.Repeat(" ", len(s.message)+4))
                                return</span>
                        case &lt;-ticker.C:<span class="cov0" title="0">
                                s.mu.Lock()
                                frame := SpinnerFrames[s.frameIdx%len(SpinnerFrames)]
                                s.frameIdx++
                                msg := s.message
                                s.mu.Unlock()

                                fmt.Fprintf(s.out, "\r%s %s", Cyan+frame+Reset, msg)</span>
                        }
                }
        }()
}

// Stop stops the spinner
func (s *Spinner) Stop() <span class="cov0" title="0">{
        s.mu.Lock()
        if !s.active </span><span class="cov0" title="0">{
                s.mu.Unlock()
                return
        }</span>
        <span class="cov0" title="0">s.active = false
        s.mu.Unlock()

        close(s.stopCh)
        &lt;-s.doneCh</span>
}

// UpdateMessage updates the spinner message
func (s *Spinner) UpdateMessage(msg string) <span class="cov0" title="0">{
        s.mu.Lock()
        s.message = msg
        s.mu.Unlock()
}</span>

// stripANSI removes ANSI escape codes from a string
func stripANSI(s string) string <span class="cov5" title="25">{
        var result strings.Builder
        inEscape := false

        for i := 0; i &lt; len(s); i++ </span><span class="cov10" title="628">{
                if s[i] == '\033' </span><span class="cov6" title="55">{
                        inEscape = true
                        continue</span>
                }
                <span class="cov9" title="573">if inEscape </span><span class="cov8" title="178">{
                        if s[i] == 'm' </span><span class="cov6" title="55">{
                                inEscape = false
                        }</span>
                        <span class="cov8" title="178">continue</span>
                }
                <span class="cov9" title="395">result.WriteByte(s[i])</span>
        }

        <span class="cov5" title="25">return result.String()</span>
}

// max returns the larger of two ints
func max(a, b int) int <span class="cov3" title="6">{
        if a &gt; b </span><span class="cov1" title="2">{
                return a
        }</span>
        <span class="cov2" title="4">return b</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package main

import (
        "os"

        "github.com/scooter-indie/gh-pmu/cmd"
)

func main() <span class="cov0" title="0">{
        if err := cmd.Execute(); err != nil </span><span class="cov0" title="0">{
                os.Exit(1)
        }</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
